# 第一章：计算机系统概述

## 1.2 计算机系统层次结构

### 1.2.1 计算机硬件

#### （1） **冯诺依曼计算机的结构**

![在这里插入图片描述](https://img-blog.csdnimg.cn/45221e117b9c4c368ac3cde60ca93c6a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

> 冯诺依曼计算机的特点：
>
> - 计算机由五大部件组成：运算器、存储器、控制器、输入/输出设备
> - 指令和数据以同等地位存与存储器中，可按地址访问
> - 指令和数据用二进制表示
> - 指令 = 操作码 + 地址码
> - 指令在存储器内按顺序存放
> - 以运算器为中心（输入/输出设备与存储器之间的数据通过运算器完成）

> - **基本工作方式：==控制流驱动方式==**
> - **最根本的特征是“存储程序”原理；**
> - **程序的功能都通过中央处理器执行指令实现**
> - **指令和数据用二进制表示，以同等地位存于存储器内，形式上无差别，只在程序执行时具有不同的含义**
> - **指令按地址访问，数据由指令的地址码指出，除立即寻址外，数据均存放在存储器内**
> - **在执行程序前，指令和数据需预先存放在存储器中，中央处理器可以从存储器存取代码**
> - 冯诺依曼机是单处理机；
> - 统一编址，指令和数据在存储单元中无差异；
> - 虽然指令和数据都以二进制形式存放在存储器中，但CPU可以根据==指令周期的不同阶段==来区分是指令还是数据，通常在取指令阶段取出的是指令，在执行阶段取出的是数据。CPU只有在确定取出的是指令后，才会将其操作码送去译码，因此不可能依据译码的结果来区分指令和数据。



#### （2）**现代计算机的结构**

![在这里插入图片描述](https://img-blog.csdnimg.cn/5fc2e03cd30344e38db172706a9b6cc2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

> 现代计算机的特点：
>
> - 以存储器为中心
> - 主机 = CPU + 主存储器
> - CPU = 运算器 + 控制器
> - 存储器 = 内存（主存） + 外存（辅存）

![在这里插入图片描述](https://img-blog.csdnimg.cn/1cedb189d41644ec9131baa0fd6390bf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_13,color_FFFFFF,t_70,g_se,x_16)

#### （3）**存储器的基本组成**

> 存储器 = 主存 + 辅存
>
> - **CPU能直接访问的是主存**
> - 辅存用于帮助主存记忆更多信息，**辅存中的信息必须调入主存后，才能为CPU所访问**
> - 主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为**按地址存取方式**
> - 地址译码器是主存的构成部分，不属于CPU
> - ps.**相联存储器（按内容寻址的存储器）：既可以按地址寻址又可以按内容寻址**

![在这里插入图片描述](https://img-blog.csdnimg.cn/3c9e9da2482b4e53ba9727b69b876166.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

- MAR（地址寄存器）：存放欲访存的存储单元地址

- > 地址寄存器位于CPU中，地址寄存器是用来找到数据的存放位置的，起的是控制作用，是放在控制器中的。

- MDR（数据存储器）：暂存要从$ve$存储器中读或写的信息（存放从存储单元取来的数据）

**主存储器由许多存储单元组成，每个存储单元包括多个存储元，每个存储元存储一位二进制代码‘0’或‘1’，故存储单元可以存储一串二进制代码，这串代码成为存储字，这串代码的位数称为存储字长，存储字长一般为一个字节（8bit）或字节的偶数倍，许多存储单元构成一个存储体**；

> - **MAR长度 = PC长度**
> - **存储单元个数 = 2^MAR位数^**
> - **MDR位数 = 数据线个数 = 存储字长**

例：
MAR = 4位，表示共有2^4^个存储单元
MDR = 16位，表示每个存储单元可以存放16bit

> 注意：
> 1Byte（字节）= 8bit（比特）

字和字节的关系：

在16位计算机系统中，一个字=16bit=2个字节

在32位计算机系统中，一个字=32bit=4个字节

在64位计算机系统中，一个字=64bit=8个字节

#### （4）**运算器的基本组成**

![在这里插入图片描述](https://img-blog.csdnimg.cn/e8a7af7eb25340f796a06b7c73cab90d.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/948deefadb7a4cd2836c07122d5117f7.png)

> - 累加器（ACC）：存放操作数或运算结果
> - 商乘寄存器（MQ）：在乘除运算时，用于存放操作数或运算结果
> - 操作数寄存器（X）：存放操作数
> - 算术逻辑单元（ALU）：通过内部复杂电路实现算术运算和逻辑运算
> - 变址寄存器（IX）
> - 基址寄存器（BR）
> - 程序状态存字寄存器（PSW）



#### （5）**控制器的基本组成**

![在这里插入图片描述](https://img-blog.csdnimg.cn/359924638ca64c51bc9c42db25a75cdf.png)

> - 控制单元（CU）：分析指令，给出控制信号
> - 指令寄存器（IR）：存放当前执行的指令
> - 程序计数器（PC）：存放下一条指令地址，有自动加一功能
> - 指令译码器（ID）：对指令进行译码（区分当前指令是什么指令，以形成相应的控制信号）
> - 时序发生器：按时间周而复始的发出节拍信号
> - 微操作控制部件：
>   微操作：硬件电路中不可再细分的简单操作。（微操作在一个节拍内完成
>   ）
>   根据指令的译码结果，结合CP以及时序信号发生器产生的节拍信号，产生该指令执行过程中各节拍所需要的微操作控制信号，并将它们发送给包括控制器本身在内的各个部件，使之协调、分步骤地进行操作，实现指令的执行。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ead4a68a091a45378bbcf210df01307f.png)

### 1.2.2 计算机工作过程举例

![在这里插入图片描述](https://img-blog.csdnimg.cn/91a2a30c64f84cf28e3affa4edceb7d1.png)



总结：
![在这里插入图片描述](https://img-blog.csdnimg.cn/9e873b19d33c4a9e999e5d5450d7969e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

> **CPU区分指令和数据的依据：指令周期的不同阶段**
>
> - 取址阶段：指令
> - 执行阶段：数据

> - 存储程序是将指令以代码的形式实现输入计算机主存储器，然后按其在存储器中的首地址执行程序需的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束
> - 计算机按存储程序原理应具有五大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能

### 1.2.3 计算机软件

**1.系统软件**

- 保证计算机系统高效、正确运行的**基础软件**，通常作为系统资源提供给用户使用。
- 主要包括：操作系统（OS）、数据库管理系统（DBMS）、语言处理系统、分布式软件系统、网络软件系统、标准库程序、服务性程序等

**2.应用软件**

- 是用户为解决某个领域中的各类问题而编制的程序
- 如**数据系统(DBS)**、各种科学计算类程序、工程设计类程序、数据统计与处理程序等

**注：**

1. 数据库管理系统属于系统软件，数据库系统属于应用软件；
2. 编译程序，连接程序等也属于系统软件；

**3.三个级别的语言**

- 机器语言：**计算机唯一可以直接识别的语言**
- 汇编语言：必须通过**汇编程序**的翻译将棋转换为机器语言后，才能在计算机的硬件系统上运行
- 高级语言：要经过**编译程序**编译成汇编语言，再通过汇编操作得到机器语言

**4.软件与硬件的关系**

- **软件和硬件在逻辑上是等效的**
- 硬件具有更高的执行速度
- 软件实现具有更好的灵活性
- **执行频繁、硬件实现代价不是很高的功能通常由硬件实现**

### 1.2.4 计算机系统的层次结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/34a5e8fa78844ca595d7c734a2ca03ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

> - **上下层是可分割的，上层是下层的功能实现**，只有下层没有上层也是可以的
> - **上层实现对下层的功能扩展，下层对上层有限制作用**
> - CPU存取速度：寄存器 > Cache > 内存
> - 解释程序执行速度比编译程序慢
> - 编译程序（C/C++）：将高级语言**一次性**翻译成**目标程序**，每次执行程序时，只需执行目标程序，只要源程序不变，就无须重新编译
> - 解释程序（JavaScript、Python）：**翻译一句执行一句，不生成目标程序**

![在这里插入图片描述](https://img-blog.csdnimg.cn/1e85039e46cd4cd7af68ba02e23ef4bf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

## 1.3 计算机的性能指标

### 1.3.1 计算机的主要性能指标

> **实际软件的运行情况**能全面代表计算机的性能

机器字长、数据字长、指令字长和存储字长：

三者在数值上可以相等可以不等，视不同机器而定；

**机器字长**（计算机的位数）

> - 计算机进行一次整数运算所能处理的二进制数据的位数
> - **一般等于内部寄存器的大小**，即一般情况下可通过寄存器的位数来判断机器字长；
> - 一般为字节（8位）的整数倍
> - **决定计算机的运算精度**：字长越长，数的表示范围越大，计算精度越高
> - 通常与CPU的寄存器位数、加法器有关

**存储字长：**一个存储单元中的二进制代码的位数；存储字长等于MDR的位数；

**指令字长：**一个指令字中包含的二进制代码的位数；一般为存储字长的整数倍；若指令字长为存储字长的2倍，则需要2个访存周期来取出一条指令；

**数据字长：**数据总线一次能并行传送信息的位数；它可以不等于MDR的位数；



**数据通路带宽**

> - 数据总线一次所能并行传送信息的位数

**主存容量**

> - 表示主存储器所能存储信息的最大容量
> - MAR的位数反映存储单元的个数，也反映可寻址范围的最大值
> - 总容量 = 存储单元个数 * 存储字长 （bit）
> - 总容量 = 2^MAR位数^ * MDR位数
>   eg：MAR为32位，MDR为8位。总容量 = 232 * 8 bit = 4GB

> K:210B；M:220B；G:230B；T:240B

**运算速度**

> - 吞吐量：系统在单位时间内处理请求的数量
> - 响应时间：从用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要的结果的等待时间
> - CPU周期：又称机器周期，从内存读取一条指令字的最短时间，**一个指令周期通常由若干个机器周期构成**
> - 主频：CPU内数字脉冲信号震荡的频率，单位：HZ
>   CPU主频（时钟频率）= 1/CPU时钟周期
> - CPI：执行一条指令所需的时钟周期数（不同的指令的CPI不同，甚至相同的指令CPI也可能不同）
> - 执行一条指令的时间 = CPI * CPU时钟周期
> - **CPU执行时间 = CPU时钟周期数/主频 = （指令条数 \* CPI）/主频**

- MIPS（每秒执行多少百万条指令）= 指令条数/执行时间 = **主频/平均CPI**
- FLOPS（每秒执行多少次浮点运算）= 浮点运算次数/执行时间

> 前面会有K/M/G/T等字母，代表数量单位
> K（千）=10^3^；M（百万）=10^6^；G（十亿）=10^9^；T（万亿）=10^12^，P=10^15^，E=10^18^，Z=10^21^

### 1.3.2 几个专业术语

- 系列机：具有**基本相同的体系结构**，使用**相同基本指令系统**的多个不同型号的计算机组成的一个产品系列
- 兼容：计算机软件或硬件的通用性
- 软件可移植性
- 固件：将程序固定在ROM中组成的部件，**是一种具有软件特性的硬件**，执行速度快于软件，灵活性优于硬件

![在这里插入图片描述](https://img-blog.csdnimg.cn/23a92b8c33a9479ea13efefd9e7fdb27.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/da9517e63b714fe0acaf00803b22393d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

------

## 1.4 本章知识点补充

1. 寄存器在CPU内部，速度最快；Cache采用高速的SRAM制作，而内存常用DRAM制作，其速度较Cache慢；

2. 系列机的基本特性是指令系统向后兼容；

3. 运算器和控制器中都含有寄存器，地址寄存器在控制器中；

4. 数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员构成，其中数据库管理系统是系统程序；

5. 计算机的机器字长是指数据运算的基本单位长度；

6. 寄存器由触发器构成；

7. 磁盘可以永久性存放数据和程序；

8. 用于科学计算的计算机主要评估浮点运算的性能；

9. 在CPU的寄存器中，==指令寄存器==对用户是完全透明的；

10. CPI是执行一条指令所需的时钟周期数，系统结构、指令集、计算机组织都会影响CPI，时钟频率并不会影响CPI，但可以加快指令的执行速度。

11. 当前设计高性能计算机的重要技术途径是==采用并行处理技术==；

12. 计算机“运算速度”指标的含义是每秒能执行多少条指令；

13. 利用大规模集成电路技术把计算机的运算部件和控制部件做在一块集成电路芯片上，这样的一块芯片称为**CPU**；

14. 若微机A和B的片内逻辑电路完全相同，则A和B的平均每条指令的时钟周期数相同，即CPI相同；

15. 在CPU中，IR、MAR和MDR对各类程序员都是透明的；

16. 数据字长是数据总线一次能并行传送的数据的位数；

17. 决定计算机计算精度的主要技术是计算机的字长；

18. 机器字长是指CPU内部用于整数运算的数据通路的宽度，机器字长等于CPU内部用于整数运算的**运算器**位数和**通用寄存器**宽度，机器字长反映了计算机处理信息的能力；

19. 两个微机的片内逻辑电路完全相同，则他们的CPI相等；

    

# ==第二章 数据的表示和运算==

## 2.1 数制与编码

大写字母：65（0100 0001）~ 90（0101 1010）

小写字母：97（0110 0001）~122（0111 1010）

区位码：防止信息交换时与“控制/通信字符”冲突；

### 2.1.1 进位计数制

任意进制 -> 十进制  权重乘值相加
二进制 -> 八进制 -> 十六进制 （3/4 位一组，不足补零）
十进制 -> 任意进制：

分为整数部分和小数部分

整数部分：辗转相除/除奇取余法

小数部分：乘奇取整法

==注：==在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的。

### *2.1.2 BCD码

作用：二进制转换到十进制比较麻烦，使用 BCD 码快速实现一一转换
8421码（有权码）：985 -> 1001 1000 0101
  1010 - 1111 没有定义，如果相加溢出了，就在结果上加6 将溢出的结果补零，
  剩下的四位就刚好是个位（本质因为 8421 码是4为对应 16种状态，将高位踢出以后
  相当于是将实际值踢出了 16 而踢出的值实际是用来表示十进制的进位的，就相当于多
  减去了6 所以要加回来）
余3码（无权码）：8421码 + 0011
2421码（有权码）：解决了8421 码的冗余问题，不需要加6，相当于减少了6，当出现了冗余时

### 2.1.3 字符与字符串

ASCLL码：
  可印刷字符：32 ~ 126，其余为控制，通信字符
GB 2312-80：汉字+各种符号共有7445个
  区位码：94个区，每个区94个位置（防止异常 每个位置都加上 20H 即是国标码，再每一加上
  80H就是汉字内码（都是为了避免与ASCLL码的冲突））
汉字字形码：将内码转换为字形码
字符串：
  从低地址到高地址逐个字符存储，常采用'\0'作为结尾标志
  对于多字节的数据（如汉字），可以采用大/小端存储模式
  大端模式：将数据的最高有效字节存放在低地址单元中
  小端模式：将数据的最高有效字节存放在高地址中

### *2.1.4 奇偶校验码

校验原理：
  码字：若干位代码组成的一个字叫码字
  两个码字之间的距离：将两个码字逐位对比，具有不同的位的个数称为两个码字之间的距离
  一种编码方案可能有若干个合法码字，各合法码字之间的最小距离称为"码距"

  当码距为 1 时不具备检错能力，当码距大于等于 2 时就具有检错能力，甚至纠错能力
奇偶校验码：
  奇校验码：整个校验码（有效信息位和校验位）中 1 的个数位奇数，校验位保证有奇数个 1 
  偶校验码：整个校验码（有效信息位和校验位）中 1 的个数位偶数，校验位保证有偶数个 1

  硬件实现原理：
    偶校验的硬件时间原理：各信息为进行异或运算得到的就是偶校验位
    奇校验则是偶校验取反

### *2.1.5 海明校验码

  基本思想：
    将信息位分组进行偶校验 -> 多个校验 -> 多个校验标注出错位置

    1. 需要多多少校验位？：
        信息位 + 校验位 = n + k
        校验位为 k 表示有 2 的 k次方种状态 >= n + k + 1
    2. 确定校验位的分布
       第i个校验位 放在 2 的 i-1次方的位置上
       信息位按照顺序放到其余的位置上
    3. 求校验位的值：
       分组分别进行偶校验
       一个比特位的纠错能力，两个比特位的检错能力，全校验位

### *2.1.6 循环冗余校验码（CRC）

基本思想：
  约定好一个除数，如果接受方接受到数据过后与除数相除过后与预期相比较
过程：
  根据生成多项式写出除数

  1. 确定 信息位K 和 校验位 R
  2. 移位
  3. 相除
  4. 检错和纠错

2.2 数的表示与基本运算
ASCLL码

### 2.1.7 定点数的表示

无符号数：整个机器字长的全部二进制位均为数值为，没有符号位，相当于数的绝对值
有符号数：

**原码：**用尾数表示真值是绝对值，符号位 0/1 对应 正/负 （0 有两种表示方式）
**反码：**若符号位为 0，则反码与原码相同，若符号为1，则数位全部取反（中间状态）
**补码：**正数补码等于原码，负数补码 = 反码末位加一 （补码表示真值 0 只有一种表示形式）
         整数部分比原码多一个 ==-2^n^==，小数部分比原码多一个==-1==
**移码：**补码的基础上将符号位取反。移码只能用于表示整数

> 补码：如果使用原码对正数和负数直接进行相加，无法得到正确的结果，于是出现了用加法代替减法的思想
> 移码：利于计算机中数的大小比较

技巧：由[X]~补~快速求[-X]~补~的方法

==符号位、数值位全部取反，末位加1;==

原码和反码的真值0有两种表示；补码和移码的真值0只有一种表示。若机器字长为n+1位，则：
原码和反码         ——整数表示范围−(2^n^−1) ≤ x ≤ 2^n^−1 ；小数表示范围−(1−2^−n^) ≤ x ≤ 1−2^−n^
补码					——整数表示范围−2^n^ ≤ x ≤ 2^n^−1 ；小数表示范围−1 ≤ x ≤ 1−2^−n^
移码					——整数表示范围−2^n^ ≤ x ≤ 2^n^−1 ；移码全0真值最小，移码全1真值最大



补充：

一般用移码表示浮点数的阶，而补码表示定点整数；

在计算机中，主存地址都是正数，因此不需要符号位，所以通常用无符号数表示；



## 2.2 运算方法与运算电路

### ==2.2.1 基本运算部件==

学吐了

ALU是由组合逻辑电路构成的，最基本的部件是并行加法器。由于单纯的ALU不能狗存储运算结果和中间变量，往往将ALU和寄存器或暂存器相连。

**ALU宽度通常与字长相同**；

在定点运算器中，无论是采用双符号位还是采用单符号位，必须有溢出判断电路，它一般用“异或”门来实现；



### 2.2.2 移位运算

**1.移位运算**：（**硬件由触发器实现**）

算数移位：

<img src="C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220327155544083.png" alt="image-20220327155544083" style="zoom:80%;" />

  **原码的算数移位：**通过改变各个数码为和小数点的相对位置，从而改变各数码为的位权。可用移位运算实现乘法、除法
    右移：高位补 0 ，低位舍弃。如果舍弃的位 = 0，则相当于除以 2 ；如果舍弃的不为 0 则会丢失进度
    左移：与右移类似，相当于乘以 2 如果丢弃了高位的 1 则会出现严重误差
  **反码的算术移位：**
    正数：跟原码一样
    负数：右移高位补 1 ，低位舍弃，左移低位补 1 ，高位舍弃
  **补码的算术移位：**
    正数：相同
    负数：负数补码中，最右边的 1 及其右边同原码。最右边的 1 左边同反码，右移的时候高位补1，左移的时候低位补0

在算数移位的情况下，补码左移的前提条件是其原最高有效位与原符号位要相同；若不相同，则左移会发生溢出；

在算数移位的情况下，双符号位的移位操作只有低符号位需要参加移位操作，以判断是否发生溢出，而高符号位代表真正的符号；



**2.逻辑移位**：（将操作数视为无符号数）

左移右移都补0，移出位舍弃；

**3.循环移位：**

循环移位操作特别适合将数据的低字节数据和高字节数据互换；



### 2.2.3 加减运算和溢出判断

原码的加法运算
  正+正：绝对值做加法，结果为正
  负+负：绝对值做加法，结果为负
  正+负：绝对值哒的减绝对值小的，符号同绝对值大的数

原码的减法运算
  减号取反，转变为加法

**负数补码 -->原码：**

1. 数值位取反+1；
2. 负数补码中，最右边的1以及其右边同原码，最后边的1的左边同反码；

==[-B~补~] →[B~补~]：连同符号位一起取反加1；==



**溢出的判断：**

(1) 采用一位符号位
设A的符号为A~S~，B的符号为B~S~，运算
结果的符号为S~S~，则溢出逻辑表达式
为  

![image-20220326194908655](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220326194908655.png)

若V=0，表示无溢出；
若V=1，表示有溢出。



（2）采用一位符号位，根据数据进位情况来判断溢出

|      | 符号位的进位Cs | 最高数值位的进位C1 |
| :--: | :------------: | :----------------: |
| 上溢 |       0        |         1          |
| 下溢 |       1        |         0          |


Cs和C1 相异或来判断是否发生的溢出

![image-20220823182500665](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220823182500665.png)

（3）采用双符号位结合（2）中得出的结论，可以利用双符号位来判断是上溢还是下溢

单符号位又被称为模2补码，双符号位又称为模4补码

模4补码具有模2补码的全部优点，且更易检查加减运算中的溢出问题；

模4补码实际存储时只存储1个符号位，运算时会复制一个符号位；

只在把两个模4补码的数送往ALU完成加减运算是，才把每个数的符号位的值同时送往ALU的双符号位中，即只在ALU中采用双符号位；



正数符号为00，负数符号为11
[A+C]~补~= 00,0001111 + 00,1111100 = 01,0001011 上溢
[B−C]~补~= 11,1101000 + 11,0000100 = 10,1101100 下溢
记两个符号位为S~S1~S~S2~，则V=S~S1~⊕S~S2~
若V=0，表示无溢出；若V=1，表示有溢出。



**也可使用下面的方法判断OF、CF：**

![image-20220831152411049](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220831152411049.png)



**符号扩展：**
  int -> long
正整数：原反补都一样，前面直接补0
负整数：
  原码：符号位不变，前面直接补 0 
  反码：符号位不变，前面直接补 1
  补码：符号位不变，前面直接补 1

正小数：原反补都一样，在后面直接补0
负小数：
  原码：符号位不变，在后面补0
  反码：符号位不变，在后面补1
  补码：符号位不变，在后面补0

### 2.2.4 原码和补码的乘法运算

**定点数原码乘法运算**：  原码一位乘法

<img src="C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220829174252674.png" alt="image-20220829174252674" style="zoom:80%;" />

符号位单独处理：符号位=乘数⊕被乘数
实现方法：先加法再移位，重复 n 次

若当前运算位=1，则(ACC)+[|x|]~原~；若=0，则(ACC)+0。

每轮加法后，ACC、MQ的内容统一==逻辑右移==



**定点数补码的乘法运算**：补码一位乘法

进行n轮加法、移位，最后再多来一次加法

符号位参与运算

<img src="C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220326204508245.png" alt="image-20220326204508245" style="zoom:80%;" />

n轮加法，==算术右移==，加法规则如下：

引入辅助位

辅助位-MQ中最低位 = 1 时，（ACC）+[x]补
辅助位-MQ中最低位 = 0 时，（ACC）+0
辅助位-MQ中最低位 = -1时，（ACC）+[-x]补



原码与补码乘法比较：

| 乘法类型      | 符号位参与运算 | 累加次数 | 移位次数 | 右移     |
| ------------- | -------------- | -------- | -------- | -------- |
| 原码一位乘法  | 否             | n        | n        | 逻辑右移 |
| 补码Booth乘法 | 是             | n+1      | n        | 算数右移 |



### 2.2.6 原码和补码的除法运算 

定点数的除法：恢复余数法、加减交替法（不恢复余数法）只能算小于 1 的除法运算
  计算机开始默认商 1 如果发现错误就恢复被除数 商改为 0

**原码除法：恢复余数法**

 <img src="C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220327143536320.png" alt="image-20220327143536320" style="zoom:80%;" />

若余数为负，则可直接商0，并让余数左移1位再加上|除数|；



 **补码除法：加减交替法（不恢复余数法）**

• 符号位参与运算
• 被除数/余数、除数采用双符号位

- 被除数和除数同号，则被除数减去除数；异号则加上除数

> 余数和除数同号，商1，余数左移一位减去除数
> 余数和除数异号，商0，余数左移一位减去除数
> 商末位始终置为 1



**除法运算总结：**

| 除法类型       | 符号位参与运算 | 加减次数 | 移位    | 上商、加减原则     | 说明                       |
| -------------- | -------------- | -------- | ------- | ------------------ | -------------------------- |
| 原码加减交替法 | 否             | N+1或N+2 | 左移N次 | 余数的正负         | 若最终余数为负，需恢复余数 |
| 补码加减交替法 | 是             | N+1      | 左移N次 | 余数和除数是否同号 | 商末位恒置1                |

恢复余数法：当余数为负时商0，并+|除数|，再左移，再-|除数|；

加减交替法：当余数为负时商0，并左移，再+|除数|；

### 2.2.7 强制类型转换 

无符号数和有符号数：不改变数据内容，改变解释方式；
长整数变短整数：高位截断，低位保留；

短数据变长数据：符号扩展；



注：char类型为8位无符号整数，其在转换为int时高位补0即可；



### 2.2.8 数据的存储和排列

大小端模式（地址从左到右由低变高）：
  大端模式：高地址存储低位；（符合人类习惯）
  小端模式：高地址存储高位；（符合机器）

  现代计算机通常是按字节编址，即每个字节对应一个地址
  通常也支持按字，半字，按地址寻址
  假设存储字长为 32 位，则1个字=32bit，半字=16bit。每次访问只能读/写一个字

边界对齐（空间换时间）：    ——访问一个字/半字都只需一次访存；

边界不对齐（时间换空间）：——访问一个字/半字可能需要两次访存；

*精简指令系统计算机RISC通常采用边界对齐方式，因为对齐方式取指令时间相同，因此能适应指令流水；*




## 2.3 浮点数的表示与运算

### 2.3.1 浮点数的表示

定点数的局限性：定点数可以表示的数字范围有限，但是我们不能无限制的增加数据的长度
浮点数的表示：

-   阶码：常用补码或移码表示的定点整数；可以反应浮点数的范围；
-   尾数：常用原码或补码表示的定点小数；可以反应浮点数的精度；
-   基数：一般为2，也可能是1,8,16；一般是隐含的；基数越大，范围越大，但精度变低（数变稀疏）

  

**浮点数尾数的规格化（科学计数法最高位不能为 0 的思想）**
  本质：当小数部分小于 0.5 时 二进制必定是 0.0.....就多了一个 0 导致精度丧失，这样可以让尾数左移一位，
  保证不浪费这一位，这就是浮点数的规格化

  左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减一
  右规：当浮点数运算的结果尾数出现溢出（双符号位为01 或 10）时，将尾数算数右移一位阶码加一

规格化浮点数的特点：

![image-20220828213409284](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220828213409284.png)

  1. 用原码表示的尾数进行规格化：

    正数为:0.1xxxxxx...xxx的形式，其最大值表示为 0.11....1 最小值为 0.10....0
    负数同理，只有符号位不变，其余和正数同理
  2. 用补码表示的尾数进行规格化：

    由于正数的补码和原码相同，所以和原码的规格化相同
    负数则为1.0xxxx的形式，其最大值为1.0111....1；最小值表示为 1.00000
    负数补码的规格化为算数左移，直到小数点第一位是0，负数原码规格化直接右移就行



**舍入：**

1. 舍入是浮点数的概念，定点数没有舍入的概念；
2. 浮点数舍入的情况有两种：对阶、右规格化；
3. 舍入不一定产生误差，如向下舍入11.00到11.0时是没有误差的；



### 2.3.2 IEEE 754 规范

移码：在补码的基础上将符号位取反。移码只能用于表示整数
移玛的定义：移码 = 真值 + 偏置值
由一位数符，阶码部分用移码表示，尾数用原码表示
尾数隐含了一个 1 
阶码中的 -127和-128 做特殊用途

当阶码全为 0 时，尾数 M 不全为 0 时，表示非规格化小数
当阶码全为 0 时，尾数 M 全为 0 时，表示 0
当阶码全为 1 时，尾数 M 全为 0 时，表示无穷大
当阶码全为 1 时，尾数 M 不全为 0 时，表示NAN（not a number）

### 2.3.3 浮点数的加减运算

运算步骤：

    1. 对阶：使两个数的阶码相等，小阶向大阶看齐，尾数每又移一位，阶码加 1
    2. 尾数加减
    3. 规格化
    4. 舍入
    5. 判断溢出 



溢出总结：

1. 对阶操作不会引起阶码上溢或下溢；（小阶向大阶看齐）
2. 右规和尾数舍入都可能引起阶码上溢；
3. 左规时可能引起阶码下溢；（这里下溢指超过了最小允许的数）
4. 尾数溢出时结果不一定溢出；（规格化后在判溢出）




特殊值 IEEE 754浮点数的解释：

- E=0且M=0，则真值为0；（+0还是-0看符号位）
- E=0且M≠0，为非规格化数，真值=（-1）^s^ x 0.M x 2^-126^;
- 1<=E<=254时，真值=（-1）^s^ x 1.M x 2^E-127^;
- E=255且M≠0时，真值为“NaN”（非数值）；
- E=255且M=0时，真值为正无穷或负无穷（看符号位）；



# 第三章：存储系统

## 3.1 存储器概述

### 3.1.1 存储器的分类

- 按在计算机中的作用（层次）分类

> 1. 主存储器（主存/内存）：
>
> - **用来存放计算机运行期间所需的大量程序和数据**
> - CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）以及辅助存储器交换数据
> - 特点：容量小，存取速度快，每位价格较高

> 2.  辅助存储器（辅存/外存）：
>
> - **用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息**
> - 不能与CPU进行直接交换信息
> - 特点：容量极大，存取速度慢，单位成本低

> 3. 高速缓冲存储器（Cache）：
>
> - 同于主存和CPU之间，**用来存放正在执行的程序段和数据**，以便CPU能更高速地使用它们
> - Cache的存取速度可与CPU的速度相匹配
> - 特点：存取容量小，价格高
> - 由**SRAM**组成，掉电后信息即消失，属于易失性存储器；



- 按存储介质分类

> 1. 磁表面存储器（磁盘，磁带）
> 2. 磁芯存储器
> 3. 半导体存储器（MOS型存储器、双极型存储器）
> 4. 光存储器（光盘）



- 按存取方式分类

**1.随机存取存储器（RAM）:**

>
> - **存储器的任何一个单元的内容都可以随机存取，且存取时间与存储单元的物理位置无关**
>
> - 优点：读写方便，使用灵活
>
> - 缺点：**断电信息丢失**
>
> - 静态RAM：以触发器原理寄存信息，**常用作Cache**
>
> - 动态RAM：以电容充电原理寄存信息，**常用作主存**

**2.顺序存取存储器（SAM）：**如磁带，只能按照某种顺序存取内容，读写一个存储单元所需时间取决于存储单元所在的物理位置，存取速度慢

**3.直接存取存储器（DAM）：**如磁盘、光盘，既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。

**串行访问存储器:**对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘、光盘）；

**相联存储器**的基本原理是把存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入；所以它是按内容或地址进行寻址的，价格比较昂贵；一般用来制作TLB，相联Cache等；



- 按信息的可更改性分类

1. 只读存储器（ROM）：
>
> - **存储器的内容只能随机读出而不能写入**
> - 信息一旦写入就固定不变，断电内容不会丢失（常用来存放固定不变的程序、常数、汉字字库，甚至用于操作系统的固化）
> - **ROM与RAM一起构成了主存，且都支持随机存取**
> - 优点：结构简单，位密度比可读写存储器的高；可靠性高（非易失性）
> - 包括掩膜型只读存储器（MROM）、可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）、电可擦除可编程只读存储器（EEPROM）、快擦除读写存储器（Flash Memory），名称中有E表示可擦除的

**注：**

- **ROM和RAM都有随机存取的特性（直接访问存储器中的任何一个存储单元）**
- **CD-ROM特指光盘，只有只读特性，没有随机存取特性，不属于只读存储器（ROM）**
- **随机存取与随机存储器（RAM）不是一个概念，只读存储器（ROM）也是随机存取的，因此支持随机存取的存储器不一定是RAM；**



- 按信息的可保存性分类

> 1. 易失性存储器：断电后存储信息消失（如RAM）
> 2. 非易失性存储器：断电后信息仍保持（如ROM、磁表面存储器、光存储器）
> 3. 破坏性读出：读出信息后原信息被破坏，**具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息**
> 4. 非破坏性读出：读出信息后原有信息不被破坏



### 3.1.2 存储器的性能指标

**大容量、低成本、高速度**

> 1. 存储容量 = **存储字数 \* 字长**
>
>    1B（Byte，字节）=8b（bit，位）
>
> - 存储字数表示存储器的地址空间大小，即存储器的存储单元数目
> - 字长即存储字长，表示一次存取操作的数据量

> 1. 单位成本：每位价格 = 总成本/总容量

> 1. 存储速度：**数据传输率 = 数据的带宽/存储周期**
>
> - 存取时间（Ta）：**从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间**
> - 存取周期（Tm）：又称读写周期或访问周期，**指存储器进行一次完整的读写操作所需要的全部时间，==即连续两次访问存储器操作（读/写操作）之间所需的最小时间间隔**

**注：**

- **存取时间不等于存储周期，通常存储周期 > 存储时间**
- **对任何一种存储器，在读写操作后，总要一段恢复内部状态的复原时间（破坏性读出的存储器所需的复原时间更长）**
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/ed13f5cb771c4022a48671d0a870ec07.png)

### 3.1.3 多级层次的存储系统

**多级存储系统**：解决了速度、容量、成本三者间的矛盾
![在这里插入图片描述](https://img-blog.csdnimg.cn/89c2b1ce56244a0e9561ada64aab8a55.png)

> 1. "Cache - 主存"层次：
>
> - 解决CPU和主存速度不匹配的问题
> - 速度接近于Cache，容量和价格接近于主存
> - **Cache和主存间的数据调动是由硬件自动完成，对所有程序员透明**
>
> ------
>
> 1. "主存 - 辅存"层次：
>
> - 解决存储系统的容量问题
> - 速度接近于主存，容量和价格接近于辅存
> - **主存和辅助间的数据局调动由硬件和操作系统共同完成，对应用程序员透明**

> - Cache、主存可以直接与CPU交换信息
> - 辅存需要通过主存与CPU交换信息
> - 主存与CPU、Cache、辅存都能交换信息
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/eed90319b6cd44ecb1398119b444c27f.png)

**在两个层次中，上一层中的内容都只是下一层中内容的副本，即Cache中的内容只是主存中内容的一部分（或主存中的内容只是辅存中内容的一部分）**

> 寄存器：
>
> - 是有限存储容量的告诉存储部件，可以用来暂存指令、数据等
> - 通常制作在CPU芯片内
> - 寄存器中的数直接在CPU内部参与运算
> - 速度最快，价格最贵，容量最小

> 存储器带宽：
>
> - 单位时间内存储器存取的信息量
> - **= 每个存储周期可访问的位数 / 存储周期**
>   **1s = 103 ms = 106 us = 109 ns = 1012 ps**



## 3.2 主存储器

4.半导体随机存储器

> ![在这里插入图片描述](https://img-blog.csdnimg.cn/b354b37343534861b57ad17f5bbe46df.png)
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/84c9074cd719432d8244bf6d7e7183af.png)

> - 地址线是单向的
> - 数据线是双向的
> - 片选线：用于选择存储芯片
> - 读/写控制线：进行读/写操作

> **存储器的工作：保持存储信息、读文件和写数据**

### 3.2.1 SRAM芯片和DRAM芯片

**1.静态随机存储器（SRAM）**

> 存储元：
>
> - 存放一个二进制的物理器件
> - **是存储器最基本的构件**
> - **地址码相同**的多个存储元构成一个存储单元，若干存储单元的几个构成存储体

- SRAM的存储元是用==双稳态触发器（六晶体管MOS）==来记忆信息，**信息被读出后，它仍保持原状态而不需要再生 （非破坏性读出）**
- **存取速度快，但集成度低，功耗较大，所以一般用来组成Cache**



**2.动态随机存储器（DRAM）**

- 用存储元电路中栅极电容上的电荷来存储信息==（破坏性读出）==
- DRAM的基本存储元通常只用一个晶体管，所以比SRAM密度高
- **采用地址复用技术，地址线是原来的一半，且与地址信号分行、列两次传送 (片选线变为行通选+列通选)**
- **容易集成、价位低、容量大、功耗低，但存取速度慢，一般用来组成大容量主存系统**

> DRAM电容上的电荷一般只能维持1~2ms，因此即使电源不断电，信息也会自动消失，因此每隔一段时间必须刷新，通常取2ms（刷新周期）

**注：易失性存储器是指断电后数据丢失，S/DRAM都满足断电内容消失，但需要刷新的只有DRAM，SRAM不需要刷新**

> 常用的刷新方式：
>
> - **由于存储体是矩阵形式，因此每次刷新都是对行进行刷新**
> - 刷新的实质就是读出后再按原样写入
> - 没有特殊说明时刷新一行的时间等于一个存储周期（读周期/写周期）
> - 若题目说明了刷新操作由读操作和写操作一起执行，则刷新一行的周期按两倍的存储周期计算
>
> ------
>
> 1. 集中刷新：将刷新操作集中到一段时间内集中进行
>
> - 一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”
> - 优点：读写操作时不受刷新工作的影响，因此系统的存取速度较快
> - 缺点：在集中刷新期间（死区）不能访问存储器
>
> ------
>
> 1. 分散刷新：将刷新操作分散、周期性地进行
>
> - 把对每行的刷新分散到各个工作周期中，将存储器的系统工作分为两部分：牵绊部分用于正常读、写或保持；后半部分用于刷新某一行
> - 此时的存储周期不再等于读/写周期，而等于读/写周期 + 刷新一行的周期
> - 这种刷新方式增加了系统的存取周期，系统的存取周期为芯片的存储周期的两倍
> - 优点：没有死区
> - 缺点：加长了系统的存取周期，降低了整机的速度
>
> ------
>
> 1. 异步刷新：前两种方法的结合
>
> - 即可以缩短“死时间”，又能充分利用最大刷新间隔为2ms的特点
> - 将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新的请求
> - 避免使CPU连续等待过长的时间，且减少了刷新的次数，从根本上提高了整机的工作效率
> - 若将刷新安排在不需要访问存储器的译码阶段，则既不会加长存储周期，又不会产生“死时间”，这是分散刷新的发展，也称“透明刷新”
> - 注意：刷新对CPU是透明的，即刷新不依赖于外部的访问；刷新操作时仅需要行地址；刷新操作类似于读操作，但又不同。刷新操作仅给栅极电容补充电荷，不需要信息输出。刷新时不需要选片，即整个存储器中的所有芯片同时被刷新
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/e0acd88511ba47ee936ea0083cb1c9ee.png)



注：

1. **SDRAM表示同步动态随机存储器，需要每隔一段时间刷新；**现在的主存通常采用SDRAM芯片；

2. DRAM可以采用地址线复用技术，即行列在不同时间使用同一组地址线，这样可以使数据线减半，但注意同时需要增加**行选通**和**列选通**，同时，可以使用行选通来代替片选线；

   



**3. 存储器的读、写周期**

> RAM的读周期：
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20362711ec764318a005b9e0702e8b2b.png)
>
> - 读周期时间（t~RC~）：存储芯片进行两次连续读操作的最小时间间隔
> - 读时间（t~A~）:从给出有效地址开始，到读出所有选中单元的内容并在外部数据总线上稳定地出现所需的时间
> - **读周期 >= 读时间**
> - t~OC~：片选的保持时间

> RAM的写周期
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f46983f35465473f924a0fc73c1d4a53.png)
>
> - **写周期 >= 写时间**



**4.SRAM和DRAM的比较**

![在这里插入图片描述](https://img-blog.csdnimg.cn/c6e737cf0036489db4969d1521601193.png)



### 3.2.3 只读存储器（ROM）

1.掩膜型只读存储器（MROM）
>
> - 制造时写入程序，此后只能读而不能写入
> - 基本原理：以元件的“有/无”来表示“1/0”
>
> ------

2.可编程只读存储器（PROM）
>
> - 用户可根据自己需求填入内容，一旦写入，内容无法改变，属于一次性写入的存储器
> - 用熔丝存储数据
>
> ------

3.可擦除可编程只读存储器（EPROM）
>
> - 使用高压写入数据，当需要修改时，用紫外线将其内容全部擦除（不能局部擦除）
> - 写入时间长，速度慢。且改写次数有限，**不能代替RAM**
> - 用悬浮栅存储数据
>
> ------

4.电可擦除可编程只读存储器（EEPROM）
>
> - 使用高压写入、擦除数据（可局部擦除）
>
> ------

5.闪存（Flash Memory）
>
>- 可以在不加电的情况下长期保存信息
>- 可以在线进行快速擦除和重写
>- 价格便宜，集成度高，擦写速度快
>- 存储元由MOS管组成，位密度比ROM高；
>- 由于闪存需要先擦除在写入，因此闪存的“写”速度要比“读”速度更慢

U盘采用**Flash**存储器技术，它是在E^2^PROM的基础上发展起来的，属于**ROM**的一种。由于擦写速度和性价比均很可观，因此其常用作辅存；



6.固态硬盘（SSD）
>
> - 由控制单元和存储单元组成；
>
> - 保留了Flash存储器长期保存信息、快速擦除与重写的特性；
> - 对比传统硬盘具有读写速度快、低功耗的特性；
> - 缺点是价格较高；
>
> ![请添加图片描述](https://img-blog.csdnimg.cn/e8ff5573207f4c6cba2a58ad19ee0e40.png)

### 3.2.3 主存储器的基本组成



### 3.2.4 双口RAM和多模块存储器

#### 1.双端口RAM

![在这里插入图片描述](https://img-blog.csdnimg.cn/20e273670b014ec18566ef66a0c247cf.png)

**寄存器有左右两个独立的窗口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步访问存储单元**

> 两端口对同一主存的操作：
>
> - 两端口不同时对同一地址单元存取数据：不出错
> - 两端口同时对同一地址单元读出数据：不出错
> - 两端口同时对同一地址单元写入数据：写入出错
> - 两端口同时对同一地址单元，一个写入数据，一个读出数据：读出出错
>
> **解决方法：** 通过“BUSY”标志，由判断逻辑决定暂时关闭一个端口，为关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问（延时）



#### **2. 多模块存储器**

（用于提高访存速度）

 **(1)单体多字存储器**

**指令和数据在主存内必须连续存放，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显**
![在这里插入图片描述](https://img-blog.csdnimg.cn/8089e235cde8403f8e5c16ba42018292.png)
把存储器的存储字长增加n倍（上图中n=4），以存放n个指令字或数据字，于是单体多字存储器的最大带宽比单体单字存储器的最大带宽提高n倍

- 每个存储单元存储m个字
- 总线宽度也为m个字
- 一次并行读出m个字

每次只能同时取m个字，不能单独取其中某个字，指令和数据在主存内必须是连续存放的；

优点：有利于提高存储器每个字的平均读写速度；

缺点：灵活性不如单体字结构的存储器，还会多用到几个缓冲存储器；



**(2) 多体并行存储器**

采用多个模块组成的存储器，每个模块具有相同的容量和存取速度，各模块都有独立的地址寄存器、数据寄存器、地址译码器和读/写电路。每个模块都可以看做一个独立的存储器，它们既可以并行工作，也可以交叉工作
分为**高位交叉编址（顺序方式）** 和**低位交叉编址（交叉方式）** 两种

(2.1) 高位交叉编址：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2ea93aef18ac4af9bdc8b777154f5fbd.png)

> - 每个模块内的体内地址顺序是连续的（一个体存满后，再存入下一个体）
> - **高位地址表示体号，地位地址表示体内地址**
> - 可以同一时间使得不同的请求源同时访问不同的体，进而实现个体的并行工作
> - 优点：利于存储器的扩充，只需将存储单元的编号往后加
> - 缺点：由于各个模块一个接一个地串行工作，因此存储器的带宽受到了限制

(2.2) 低位交叉编址：

![在这里插入图片描述](https://img-blog.csdnimg.cn/fa616fd10a164d648a0e6eb57249cb62.png)

> - **低位地址表示体号，高位地址表示体内地址**
> - 连续地址分布在相邻的不同模块内，而同一个模块的地址都是不连续的
> - 可以实现**多模块流水线式并行存取**，大大提高存储器的带宽
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/e6772f5fc33f42c08c497e84bddd1b75.png)
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/541bb56acc464a668dc84b15ac624afc.png)

**低位交叉编址：**

- 轮流启动：

  ![image-20221019155746213](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20221019155746213.png)

  1. 每个存储体的存储字 = 总线宽度
  2. 存储体周期T = 总线传输周期r * 模块数m

- 同时启动：

  ![image-20221019155809092](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20221019155809092.png)

  1. 每个存储体的存储字 * 模块数m = 总线宽度
  2. 存储体周期T = 总线传输周期r

(2.3) 总结

> - 高位交叉编址中的并行体现在**不同的请求源**并行访问不同的体
> - 低位交叉编址中的并行体现在**同一请求源**并行访问不同的体

![在这里插入图片描述](https://img-blog.csdnimg.cn/45394702d5ac41e9a6b1bbbdf173ad63.png)





==比较采用四体地位地址交叉的存储器和四端口读出的存储器这两种方案的优缺点？==

答：多端口存储器是对同一个存储体使用多套读写电路实现的，扩大存储容量的难度显然比多体结构的存储器要大，而且不能对多端口存储器的同一个存储单元同时执行多个写入操作，而多体结构的存储器则允许在同一个存储周期对几个存储体执行写入操作。

## 3.3 主存储器与CPU的连接

### 3.3.1 连接原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/a0720c856af84dfd8be3a49891572131.png)

### 3.3.2 主存容量的扩展

**若要将容量为 a \* b 的芯片组成为容量为 c \* d 的芯片，需要的芯片数量 n = (c \* d) / (a \* b)**

ps：a是字线，连接地址线；b是位线，连接数据线

> 1. 位扩充（增加b）：**增加存储字长**
>
> - 所有存储芯片的片选信号线是连在一起的
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/629d637531f64094a6aeb86662292b49.png)
>
> ------
>
> 1. 字扩充（增加a）：**增加存储单元的个数**
>
> - 片选信号线分开连接
> - 每个芯片都应和所有数据线连接
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/b6ade49f17c541f49a2f30b2c77a3562.png)
>
> ------
>
> 1. 字位扩充（同时增加a、b）：**既增加存储字的数量，有增加存储字长**
>
> - 个芯片连接地址先的方式相同，而连接数据线的方式不同，且需要通过片选信号或采用译码器设计连接到相应的芯片
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/6d9a1cc3b55849fea172fa6b53504ef1.png)

- MAR决定主存地址空间；


## 3.4 外部存储器

### 3.4.1 磁盘存储器

硬盘存储器的组成：硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成；

磁盘的容量：格式化后的容量比非格式化容量要小；

硬盘属于机械式部件，其读写操作是串行的；

能够提高RAID可靠性的措施主要是对磁盘进行镜像处理和奇偶校验；

磁盘存储器的最小读写单位是一个扇区，即磁盘按块存取；

磁盘扇区中包含数据、地址和校验等信息；

### 3.4.2 固态硬盘

固态硬盘（SSD）数据是以页为单位读写的，只有在一页所属的块整个被擦除后，才能写这一页；

SSD容易磨损；

## ==3.5 高速缓冲存储器（Cache）==

> **一般Cache采用高速度SRAM制作（主存一般使用DRAM）** ，速度更快，容量更小，价格更高

### 3.5.1 Cache的工作原理

**原理：利用程序访问的局部性原理，将CPU近期需要的程序提前存放到Cache中**

> 1. 时间局部性：如果某个数据或指令被使用，那么不久将可能再被使用
> 2. 空间局部性：如果某个数据或指令被使用，那么附近数据也可能被引用

![在这里插入图片描述](https://img-blog.csdnimg.cn/000b8508c43e474297912dcfca4ea2fe.png)

> C << M
>
> - **命中率：** CPU要访问的信息在Cache中的比例
> - **平均访问时间：** 设命中率为h，命中时Cache的访问时间为t~c~，未命中时访问主存的时间为t~m~，则Cache-主存的平均访问时间**t~a~ =h*t~c~+ (1-h)*t~m~**
> - **Cache-主存系统效率：e=t~c~/t~a~**
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/ef1a875c8ec742c9ad285a29337c5736.png)

> **注：**
>
> - **Cache的命中率只与Cache的容量、Cache的字块长度有关**
> - CPU与Cache之间传送数据的基本单位是**字**，主存与Cache之间传送数据的基本单位是**块（一个块包含多个字）**
> - CPU访问主存时，会将地址同时送给Cache和主存，Cache控制逻辑依据地址判断此字是否在Cache中，若在，则立即传送给CPU，否则，用主存**读周期**把此字从主存读出并送到CPU。同时，把含有这个字的**整个数据块（是整个包含此字的数据块，不仅仅是这个字）** 从主存读出并送到Cache中

![在这里插入图片描述](https://img-blog.csdnimg.cn/88dba736da19478eb56b644fee857cc6.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/86d8178697e340a89dd883ce713792f7.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/9ac7e128e747487da2366af896f734f1.png)

### 3.5.2 Cache和主存的映射方式

1.**直接映射**
![在这里插入图片描述](https://img-blog.csdnimg.cn/f678b490966243218cfa7482b2138490.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/dd0488f944244921a34fe8b6f1f8ed0d.png)

> **i = j mod C**
> i为Cache的块号，j为主存中的块号，C为Cache的块数
>
> - 优点：实现简单
> - 缺点：不够灵活，冲突概率高（抖动）

![在这里插入图片描述](https://img-blog.csdnimg.cn/5810ab98ca9c4668a296f16a6b8aef4d.png)

> **操作原理：**
> 先访问存储地址中间的c位，找到对应的Cache行，将对应Cache行中的标记和主存地址的t位进行比较，若相等且有效位为1，则访问Cache“命中”，此时根据b位在对应的Cache行中存取信息；若不相等或有效位为0，则“不命中”，需要从主存中读取所需要的块来替换Cache中旧的块，同时将信息送往CPU，并修改Cache的标记，若原来有效位为0，需要将有效位置1

2.**全相联映射**
![在这里插入图片描述](https://img-blog.csdnimg.cn/f6d3a3ee7097431188d7f3c11f937c78.png)

> 主存中的每一块可以装入Cache的任何位置，每行的标记用于指出该行取自主存的哪一行。
>
> - **Cache标记位数 = log~2~主存的行数**
> - 优点：提高了Cache的命中率；减小了块的冲突率；提高了Cache的利用率
> - 缺点：tag位数增加，标记的比较速度慢。这种比较常用 **按内容寻址** 的相联存储器完成

![在这里插入图片描述](https://img-blog.csdnimg.cn/16bb0978fe9744fa9abb47a8f1f637d0.png)

> **操作原理：**
> CPU访存指令指出一个内存地址，该内存地址包含块号、字等字段。Cache的所有行的标记位和内存地址的块号一同送入比较器中比较，如果块号命中，则直接从Cache命中的块号中读取所需的字；若不命中，则按内存地址读取这个字，同时把内存块读入Cache行中

1. **组相联映射**
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/c4070b170a6543699f63702fdb724f6b.png)

> **i = j mod Q**
> i是Cache行的组号，j是主存的块号，Q是Cache的组数
> 将Cache分为Q组，主存的一个数据块可以装入一组内的任何一个位置，即组间采用直接映射，组内采用全相联映射

> ![在这里插入图片描述](https://img-blog.csdnimg.cn/9c6df786c7f04483853b2c327e1d6be9.png)
>
> - **块内字地址 = log~2~块大小**
> - **组号 = log~2~Cache组数**
> - **标记 tag = 主存地址的其余位**

![在这里插入图片描述](https://img-blog.csdnimg.cn/d873e4171e0d4270b0d7b61b292a4391.png)

1. 总结
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/f3b61559b1524d38b50e02bf6a682f59.png)

> **操作原理：**
> CPU访存指令指出一个内存地址，该内存地址包含块号、字等字段。然后通过组号找出Cache中对应的组，再将Cache该组中所有行的标记tag位和内存地址的tag一同送入比较器中比较，如果命中，通过内存地址的低b位确定需要该块中的哪一个字，再进行存取操作；若不命中，则去内存址读取需要的字，同时把内存块读入Cache行中

**地址映射表：**

是否有信息位---有效位

是否是所需要的信息---主存字块标记

是否已修改---一致性维护



### 3.5.3 Cache中主存块的替换算法

**1.随机算法（RAND）**

若Cache已满，则随机选择一块替换；

特点：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定；

**2.先进先出算法（FIFO）**

若Cache已满，则替换最先被调入Cache的块；

特点：实现简单，最开始按#0#1#2#3放入Cache，之后轮流替换#0#1#2#3
FIFO依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的；

**3.近期最少使用算法（LRU）【重点掌握】**

依据程序访问的局部性原理，选择近期内长久未访问过的Cathe行作为替换的行，平均命中率要比FIFO的高，是==堆栈类算法==；

为每一个Cache块设置一个“计数器”，用于记录每个Cache块已经有多久没被访问了。当Cache满后替换“计数器”最大的；

①命中时，所命中的行的计数器清零，==比其低的计数器加1，其余不变==；
②未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；
③未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。

Cache块的总数=2^n^，则计数器只需n位。且Cache装满后所有计数器的值一定不重复;

特点：

基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，Cache命中率高。
若被频繁访问的主存块数量> Cache行的数量，则有可能发生“抖动”，如：{1,2,3,4,5,1,2,3,4,5,1,2…}

**4.最不经常使用算法（LFU）**

为每一个Cache块设置一个“计数器”，用于记录每个Cache块被访问过几次。当Cache满后替换“计数器”最小的；

新调入的块计数器=0，之后每被访问一次计数器+1。需要替换时，选择计数器最小的一行；

注：若有多个计数器最小的行，可按行号递增、或FIFO策略进行选择；

特点：曾经被经常访问的主存块在未来不一定会用到（如：微信视频聊天相关的块），并没有很好地遵循局部性原理，因此实际运行效果不如LRU；

![](D:\考研\专业课\数据结构\数据结构\Cache替换算法.png)

### 3.5.4 Cathe写策略

**写命中：**

1.回写法：

当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存；

*减少了访存次数，但存在数据不一致的隐患。*

2.全写法：

当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲(write buffer)；

*访存次数增加，速度变慢，但更能保证数据一致性；*

使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞；

**写不命中**

1.写分配法：当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改；

==搭配写回法使用==

2.非写分配法：当CPU对Cache写不命中时只写入主存，不调入Cache；
==搭配全写法使用==

现代计算机通常采用多级Cathe结构，各级Cathe之间常采用“全写法+非写分配法”，Cathe和主存间常采用“写回法+写分配法”；

##  3.6 虚拟存储器

主存和辅存共同构成了虚拟存储器；

虚地址比实地址要大得多；

### 3.6.2 页式虚拟存储器

一个进程对应一张页表；当一个进程被调度时，会查看该进程的PCB，PCB中查到页表始址，页表始址会被操作系统放到CPU中的页表始址寄存器当中，即被切换一个进程，相当于切换了一个页表；当新进程上处理机运行时，以前的TLB中保存的页表副本将作废；（注：Cache中的数据不会作废，只有当Cache满时，才会以一定的算法将一些Cache块换出）



Cache缺失处理由硬件完成，缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现；TAB缺失既可以用硬件又可以用软件来处理；

![](D:\考研\专业课\数据结构\数据结构\存储系统图.png)

上图补充：

页（页框）大小设置是磁盘读写的单位，是磁盘与主存交换的单位；

主存块是主存和Cache之间交换的单位；

重点：**Cache每行的位数=数据部分（Cache块的大小，单位：B）+控制部分（tag标记，有效位，脏位，替换信息位）**



TLB构成：

<img src="D:\考研\专业课\数据结构\数据结构\TLB构成.png" style="zoom:80%;" />

逻辑地址/页面大小=逻辑页号；

逻辑地址%页面大小=页内偏移量；（与上图结合理解）



# 第四章：指令系统

![在这里插入图片描述](https://img-blog.csdnimg.cn/9ac3fc5558b2492b9f251cefcb7fc4d6.png)

## 4.1 指令格式

> **指令：是计算机运行的最小功能单位**
>
> **指令系统（指令集）：一台计算机的所有指令的集合，位于软件和硬件的交界面上**
>
> **指令 = 操作码 + 地址码**
>
> - 操作码：指出指令应该执行什么性质的操作和具有何种功能，是识别指令、了解指令功能、区分操作数地址内容的组成和使用方法等的关键信息
> - 地址码：给出被操作的信息（指令或数据）的地址，包括参加运算的操作数所在的地址、运算结构保存的地址、程序的转移地址、被调用的子程序的入口地址等

> **指令的长度：一条指令中所包含的二进制代码的位数**
>
> - 指令字长取决于操作码的长度、操作数地址码的长度、操作数地址的个数
> - 指令长度一般为字节的整数倍

### 1.1 指令的分类

**指令操作数的直接寻址范围 = 2^地址码位数^**

**n位操作码字段的指令最大能表示2^n^条指令**

> 按指令长度与机器字长的关系分：
>
> - 单字长指令：指令长度=机器字长
> - 半字长指令：指令长度=半个机器字长
> - 双字长指令：指令长度=两个机器字长

> 按指令长度是否相等分：
>
> - 定长指令字结构：指令系统中所有指令的长度都相等（执行速度快，控制简单）
> - 变长指令字结构：各种指令的长度随指令功能各异

> 按指令中操作数的地址码的数目分：
>
> - 零地址指令：只给操作码OP，无显式地址
>
>   1.不需要操作数的指令：空操作指令、停机指令、关中断指令等
>
>   2.零地址的运算类指令**仅用在堆栈计算机中**，通常参与运算符的两个操作数隐含地从**栈顶和次栈顶**弹出，送到运算器进行运算，运算结果再隐含地压入堆栈
>
> - 一地址指令：
>
>   1.OP(A1)→A1：只有目的操作数的单操作数指令，按A1地址读取操作数，进行OP操作后，结果存回原地址（加一、减一、求反、求补等）
>
>   2.(ACC)OP(A1)→ACC：隐含约定目的地址的双操作指令，按指令地址A1可读去源操作数，指令可隐含约定另一个操作数由**ACC**提供，运算结果也存放在ACC中
>
> - 二地址指令：
>
>   (A1)OP(A2)→A1：给出目的操作数和源操作数，运算结果存于目的操作数地址
>
> - 三地址指令：
>
>   (A1)OP(A2)→A3
>
> - 四地址指令：
>
>   (A1)OP(A2)→A3，A4 = 下一条将要执行指令的地址

在CPU执行指令的过程中，PC存放当前欲执行的指令的地址，而指令的地址码字段则保存操作数地址；

==中断隐指令==是由硬件实现的，并不是指令系统中存在的指令，更不可能属于程序控制类指令；

特权指令是指仅用于操作系统或其他系统软件的指令，为确保系统与数据安全起见，这类指令不提供给用户使用；

堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。若是软堆栈（堆栈区由内存实现），则对于双目运算需要访问4次内存：取指、取源数1、取源数2、存结果。若是硬堆栈（堆栈区由寄存器实现），则只需在取指令时访问一次内存；

为了便于取指，指令的长度通常为存储字长的整数倍；

单地址指令也可能由于单地址的寻址方式不同而导致指令长度不同；

单字长指令可以加快取指令的速度；

单地址指令中只有一个地址码，在完成两个操作数的算术运算时，一个操作数由地址码指出，另一个操作数通常存放在累加寄存器（ACC）中，属于==隐含寻址==；



### 1.2 扩展操作码指令格式

变长度操作码：全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上

常见的变长操作码方法：**扩展操作码**（操作码的长度随地址码的减少而增加）

![.](https://img-blog.csdnimg.cn/3f20d279dc494dd5ac3e375626b99fc3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

> - **不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同**
>
> - **各指令的操作码一定不能重复**
>
> - **通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码**
>
> - **地址长度为n，上层留出m种状态，下一层可扩展出m×2n种状态**
>
>   eg.二地址指令条数最大值 = (2三地址指令操作码位数 - 三地址指令条数) × 2二地址操作码位数-三地址操作码位数



## 4.2 指令的寻址方式

### 2.1指令寻址

**寻找下一条将要执行的指令地址**

- 顺序寻址：
  通过程序计数器（PC）加1（1个指令字长），自动形成下一条指令的地址
- 跳跃寻址
  通过转移类指令实现，是否跳跃受**状态寄存器和操作数**的控制，而跳跃到的地址分为绝对地址和相对地址，**跳跃的结果是当前指令修改PC值**

### 2.2 数据寻址

**寻找操作数的地址**
![在这里插入图片描述](https://img-blog.csdnimg.cn/bf91d505406b445980171ace2be989ef.png)
寻址特征：指明属于那种寻址方式

> 1. 隐含寻址：
>    不明显地给出操作数地址，而在指令中隐含操作数地址
>
> - 优点：利于缩短指令字长，可以简化地址结构
> - 缺点：需增加存储操作数或隐含地址的硬件
>
> ------
>
> eg.累加器（ACC）对单地址指令格式来说是隐含寻址
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/916aacbb1347426fbb93dcbc0af18fd7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_15,color_FFFFFF,t_70,g_se,x_16)

> 1. 立即寻址：
>    指令的地址字段直接指出操作数本身，又称立即数
>
> - 优点：在执行阶段不访问主存，**指令执行时间最短**
> - 缺点：A的位数限制了立即数的范围
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/a5e61dd26280472f878f00212360d943.png)

> 1. 直接寻址：
>    指令字中的形式地址A是操作数的真实地址EA，EA = A
>
> - 优点：简单，指令在执行阶段只访问一次主存，不需要专门计算操作的地址
> - 缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改
>   **无条件转移指令的功能是将指令中的地址码送入PC中**
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/fd6506e3cbb8463ab94e624dfa9f698a.png)

> 1. 间接寻址：
>    指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数地址的地址，EA = (A)
>
> - 优点：扩大寻址范围（EA位数 > A位数）；便于编制程序（用间接选址可方便地完成子程序返回）
> - 缺点：访问速度慢，指令在执行阶段要多次访存
> - 间接寻址可以是一次间接寻址，也可以是多次间接寻址
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/65614aa38104489684103983a0ac978c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_20,color_FFFFFF,t_70,g_se,x_16)

> 1. 寄存器寻址：
>    指令字中直接给出操作数所在的寄存器变化，EA = Ri
>
> - 优点：执行速度快，支持向量/矩阵运算；指令在执行阶段不访问主存，只访问寄存器，地址段位数短
> - 缺点：计算机中寄存器个数有限
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/83fbc9e2e2f4452ab8f0a9279fe000d5.png)

> 1. 寄存器间接寻址：
>    在寄存器Ri中给出的不是一个操作数，而是操作数所在的主存单元的地址，EA = (Ri)
>
> - 比一般间接寻址更快，但指令的执行阶段需要访问主存
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/0fe07b143e734fa2bf3188e9d19963a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_16,color_FFFFFF,t_70,g_se,x_16)

> 1. 相对寻址：
>    把程序计数器（PC）的内容加指令格式中形式地址A二形成操作数的有效地址，EA = (PC) + A**(A是补码表示！！！)**
>
> - 优点：操作数的地址不固定，随PC值变化，且与指令地址之间总差一个固定值，因此便于程序浮动，是多道程序设计中最重要的寻址方式
> - **广泛应用于转移指令**
> - **注意：由于读取指令后PC自动加1，所以A是相对于下一条指令地址的偏移量**
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/fdca9cfcec894946a40d18bb039b06b7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVGFyZW5jaA==,size_17,color_FFFFFF,t_70,g_se,x_16)![在这里插入图片描述](https://img-blog.csdnimg.cn/033b01af71b344b998e33e5b6eaa7487.png)

> ps.对于转移指令 JMP A，当CPU从存储器中取出一字节时，会自动执行(PC) + 1 → PC，若转移指令的地址为X，却占2B，在取出该指令后，PC的值会增2，即(PC) = X + 2，这样执行完该指令后，会自动跳转到X + 2 + A的地址继续执行

> 1. 基址寻址：
>    将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A而形成操作数的有效地址，EA = (BR) + A
>
> - 寄存器可以是专用寄存器，也可以是通用寄存器
> - 基址寄存器是**面向操作系统**的，其内容由**操作系统或管理程序**确定，主要用于解决程序逻辑空间与存储器物理空间的无关性
> - **采用通用寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统决定**
> - 优点：扩大寻址范围，用户不必考虑自己的程序存于主存中哪个空间区域，利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/4b799ee1d210436f882e7c4cc165123b.png)

> 1. 变址寻址：
>    有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，EA = (IX) + A
>
> - IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器
> - 变址寄存器是**面向用户的**，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）
> - 优点：扩大寻址范围，适合编制**循环程序**
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/140fface155841cd9e9f8aaf2578093f.png)

**变址寻址与基址寻址的区别：**

- 基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，程序的执行过程中其值不可变，而指令字中的A是可变的**（BR为基地址，A为偏移量）**
- 变址寻址面向用户，主要用于处理数组问题，变址寄存器的内容由用户设定，程序执行过程中其值可变，而指令字中的A是不可变的**（A为基地址，IX为偏移量）**
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/e1c4fd9eb6d24fc4bad0ab50fe2f7b1e.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/28b5bb4658d345659a93aa0d191db702.png)

> 1. 堆栈寻址：
>
> - 堆栈：
>   存储器（或专用寄存器组）中一块特定的，按后进先出（LIFO）原则管理的存储区，该存储区中读写单元的地址由堆栈指针（SP）给出。
>   硬堆栈：寄存器堆栈
>   软堆栈：从主存中划出一段区域来做堆栈
> - 采用堆栈结构体的计算机系统中，大部分指令表面上都表现为**无操作数指令**的形式，因为**操作数地址都隐含使用 了SP**。通常情况下，**在读写堆栈中的一个单元前后都伴有自动完成对SP内容的增量或减量操作**

![在这里插入图片描述](https://img-blog.csdnimg.cn/ae94820a411044f3975a1cb0095039ef.png)

**总结：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/71c789e204bd40deb87a8f08b86660ec.png)

课后题知识点：

1、采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性；但也提高了指令译码的复杂度；程序控制是靠转移指令而非寻址方式实现的；

2、直接寻址的无条件转移指令的功能是将指令中的地址码送入程序计数器（PC）；

3、为了缩短指令中某个地址段的位数，有效的方法是采取寄存区寻址；

4、隐地址不给出明显的操作数地址，而在指令中隐含操作数的地址，因此可以简化地址结构，如零地址指令；

5、机器按字寻址，程序计数器（PC）给出下一条指令字的访存地址（指令在内存中的地址），因此程序计数器的位数取决于存储器的字数；指令寄存器（IR）用于接收取得的指令，因此取决于指令字长；

6、转移指令、子程序调用与返回指令用于解决变动程序中指令执行次数的需求，而不是数据调用次序的需求；

7、若指令系统采用定长操作码格式，则立即寻址方式执行速度最快；

​	  若采用变长指令码格式，则寄存器寻址方式执行速度最快；P176

8、多道程序设计是指程序在内存中存在位置浮动，所以一般采用偏移寻址；

9、内存地址里面的数都为**无符号数**；



## 4.3 X86汇编指令入门

- X86处理器有8个32位的通用寄存器
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/7a3fd60c035846ff89a9c5085eb01b8f.png)

> - <reg>表示任意寄存器，后面的数字表示其位数
> - <mem>表示内存地址
> - <con>表示常数，后面的数字表示其位数
> - byte：单字节（Byte）
> - word：双字节（2Byte）
> - dword：四字节（4Byte）

**汇编指令通常可以分为数据传送指令、逻辑计算指令、控制流指令**



### 4.3.1 数据传送指令

> 1. mov指令：
>    将第二个操作数（*寄存器的内容、内存中的内容或常数值*）复制到第一个操作数（*寄存器或内存*），但不能用于直接从内存复制到内存
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/fcf035db306f4f1ba04a48802977f368.png)

> 1. push指令：
>    将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前将ESP的值-4（栈增长方向与内存地址增长方向相反）或+4（栈增长方向与内存地址增长方向相同），然后将操作数压入ESP指示的地址
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/3d7b7bf934c7403cb5e0906963bcd467.png)

> 1. pop指令：
>    执行出栈操作，出栈前先将ESP指示的地址中的内容出栈，然后ESP值+4或-4
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/998bb9a42c1f466a9940b6dd8acc5f7b.png)

### 3.2 算术和逻辑运算指令

> 1. add/sub指令：
>    用于两个操作数相加/相减，结果保存到第一个操作数中
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/880b69f8584249dbaf8b0f8296140319.png)

> 1. inc/dec指令：
>    将操作数自加1/自减1
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/2c639b13b69b4691952b8ecee67d5b66.png)

> 1. imul指令：
>    带符号整数相乘
>
> - 两个操作数：两数相乘后结果保留至第一个操作数中
> - 三个操作数：将第二个和第三个操作数相乘后结果保存至第一个操作数中（*第一个操作数必须是寄存器*）
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/9760ff0e1d1b4e0f80d636e9fcf9e6f5.png)

> 1. idiv指令：
>    只有一个操作数，即除数，被除数为edx:eax中的内容，操作结果有两部分：商和余数，商送到eax，余数送到edx
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/adeb0e5b7004420991045f37ebd6eabd.png)

> 1. and/or/xor指令：
>    逻辑与、逻辑或、逻辑异或操作还做了，操作结果放在第一个操作数中
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/8a7eca4728b64b50a4cab8737eca9bcc.png)

> 1. not指令：
>    位翻转指令，0→1,1→0
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/9b1fcb889c4149bfa689dfb1c23d8b9b.png)

> 1. neg指令：
>    取负指令
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/a5004e43127d42d8b64d5740c182c52a.png)

> 1. shl/shr指令：
>    逻辑左移/右移指令，第一个操作数表示被操作数，第二个操作数百奥赛位移的位数
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/e4d2e38858634c56ba984124a15f4d91.png)

### 3.3 控制流指令

**IP：指示当前执行指令的指令指针，一条指令执行后，此指针自动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新**

> 1. jmp指令：
>    控制IP转移到label所指示的地址
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/c6efe5e9809f42c99b0ec42247ac9bd0.png)

> 1. jcondition指令：
>    条件转移指令，依据处理机状态字中的一系列条件状态转移。处理机状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/a3d83edc38d346c8adba9e49edea47a8.png)

> 1. cmp指令：
>    比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/7114d7073f084b6f8061616e863f0169.png)

> 1. call/ret指令：
>    实现子程序（过程、函数等）的调用及返回。
>
> - call指令将当前执行指令地址入栈，然后无条件转移到由标签指示的指令，**call指令保存调用之前的地址信息**（当call指令结束后，返回调用之前的地址）
> - ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/dee41386cedf4851a052b2464d3beae2.png)

## 4.4 CISC和RISC

### 4.4.1 复杂指令系统计算机（CISC）

设计思路：一条指令完成一个复杂的基本功能
代表：x86架构，主要用于笔记本、台式机等

> 特点：
>
> - 指令系统复杂庞大，指令数目一般为200条以上
> - 指令的长度不固定，指令格式多，寻址方式多
> - 可以访存的指令不受限制
> - 各种指令使用频度差别大
> - 各种指令执行时间差别大，大多数指令需要多个时钟周期才能完成
> - 控制器大多数采用微程序控制，有些指令十分复杂，无法采用硬连线控制
> - 难以用优化编译器生成高效的目标代码

### 4.4.2 精简指令系统计算机（RISC）

设计思路：一条指令完成一个基本的动作，多条指令组合完成一个复杂的基本功能
代表：ARM架构，主要用于手机、平板等

> 特点
>
> - 选取使用频率较高的一些简单指令，复杂指令的功能由简单指令的组合来实现
> - 指令长度固定，指令格式种类少，寻址方式种类少
> - 只有Load/Store指令访存，其余指令的操作都在寄存器之间进行
> - CPU中通用寄存器的数量相当多
> - RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成
> - 以硬布线控制为主，不用或少用微程序控制
> - 特别重视编译优化工作，减少程序执行时间

### 4.4.3 比较

> RISC优点：
>
> - 能充分利用VLSI芯片面积
> - 能提高运算速度
> - 便于设计，可降低成本，提高可靠性
> - 有利于编译程序代码优化

![在这里插入图片描述](https://img-blog.csdnimg.cn/4fc7312b0d924d4cb0ba22aadda6e11c.png)

## 5.总结

1. 常见指令寻址方式的特点及适用情况

> - 立即寻址操作数获取便捷，常用于给寄存器赋初值
> - 直接寻址相对于立即寻址缩短了指令长度
> - 间接寻址扩大了寻址范围，便于编制程序，**易于完成子程序返回**
> - 寄存器寻址的指令字较短，执行速度较快
> - 寄存器间接寻址扩大了寻址范围
> - 基址寻址扩大了操作数寻址范围，**适用于多道程序设计**，常用于为程序或数据分配存储空间
> - 变址寻址主要用于处理**数组问题**，适合编制**循环程序**
> - 相对寻址用于控制的程序的**执行顺序、转移等**

1. 基址寻址和变址寻址的区别

> - 基址寻址面向系统，内容通常由操作系统或管理程序确定，程序的执行过程中其值不可变，而指令字中的A是可变的**（BR为基地址，A为偏移量）**
> - 变址寻址面向用户，内容由用户设定，程序执行过程中其值可变，而指令字中的A是不可变的**（A为基地址，IX为偏移量）**
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/e1c4fd9eb6d24fc4bad0ab50fe2f7b1e.png)

1. 在指令中给出操作数的地址

> 地址指定方式：
>
> - 大端方式：指令中给出的地址是操作数最高有效字节（MSB）所在的地址
> - 小端方式：指令中给出的地址是操作数最低有效字节（LSB）所在的地址

------



# 第五章：中央处理器

![在这里插入图片描述](https://img-blog.csdnimg.cn/e4e56b70956444cb8efba49448f9889d.png)

## 5.1 CPU的功能和基本结构

> **CPU=运算器+控制器**
>
> - 运算器：对数据进行加工
> - 控制器：协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令

**CPU的功能：**

1. **指令控制：** 控制器能自动形成指令地址，并发出指令命令，将对应此地址的指令取到控制器中
2. **操作控制：** 取指令后，产生完成每条指令所需的控制命令
3. **时间控制：** 控制命令产生后，需要对各种控制命令加以时间上的控制
4. **中断处理：** 对计算机运行过程中出现的异常情况和特殊请求进行处理

**CPU的基本结构：**
指令控制、操作控制、时间控制由**控制单元（CU）完成**；数据加工由**ALU**完成；中断处理由**中断系统**完成，最后再加上一些**寄存器**，就构成了CPU

> 1. 运算器中的寄存器
>
> - 暂存寄存器：
>   **暂存从主存读来的数据**，次数据不能放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的
> - 累加寄存器（ACC）：
>   是一个通用寄存器，**存放ALU运算的结果信息**
> - 通用寄存器组：
>   **存放操作数（包括源操作数、目的操作数、中间结果）和各种地址信息等。** 常见的通用寄存器有AX,BX,CX,DX,以及SP（指示栈顶指针）等。通用寄存器对程序员不透明，程序员编程时可以充分利用通用寄存器以提高程序效率
> - 条件状态寄存器（PSW）：
>   **保存由算术指令和逻辑指令运行或测试的结果而建立的各种状态信息，如运算结果进位标志（C）、运算结果溢出标志（V）、运算结果为零标志（Z）、运算结果为负标志（N）等。** 这些标志位通常分别由以为触发器保存。此外，还可以**保存中断和系统工作状态等信息**，使CPU和系统能及时了解机器运行状态和程序运行状态
>
> 2.控制器中的寄存器
>
> - 程序计数器（PC）
>   **功能：寄存信息、计数**
>   保存将要执行的下一条指令的地址（遇到转移指令则需从指令的地址段获取）
>   PC位数=存储器地址位数=存储器的容量
> - 指令寄存器（IR）
>   **用于保存正在执行的指令**
>   执行指令时，先将其从内存取到MDR中，之后再传送至IR中
>   IR位数=指令字长
> - 存储器数据寄存器（MDR）
>   也叫数据缓冲存储器
>   **暂存由主存读出或存入主存的一条指令或一个数据字**
>   **作为CPU、内存和外存设备之间信息传送的中转站**
>   **补偿CPU、内存和外存设备之间在操作速度上的差别**
>   在**单累加器结构**的运算器中，还可以兼作操作数寄存器
> - 存储器地址寄存器（MAR）
>   **保存当前CPU所访问的内存单元的地址**
>   当CPU和内存进行信息交换时，都要使用MAR和MDR
>   信息的存入一般采用**点位-脉冲**方式

![在这里插入图片描述](https://img-blog.csdnimg.cn/914c5f6b7f814a24b2aa9425cfb9bce3.png)

**用户可见寄存器**：用户可以改变其内容（如PC，用户可以通过转移指令或调动子程序等方式改变其内容）

条件转移指令执行时，需对**标志寄存器**的内容进行测试，判断是否满足转移条件

指令寄存器中保存当前正在执行的指令，所以其位数取决于指令字长；

通用寄存器用于存放操作数和各种地址信息等，其位数与机器字长相等，因此便于操作控制；

指令译码器仅对==操作码字段==进行译码，向控制器提供特定的操作信号；

CPU中专用寄存器有程序寄存器（PC）、指令寄存器（IR）、存储器数据寄存器（MDR）、存储器地址寄存器（MAR）和程序状态字寄存器；

- 用户可见寄存器：通用寄存器组、程序状态字寄存器（PSW）、程序计数器（PC）
- 用户不可见寄存器：存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、指令寄存器（IR）、暂存寄存器

PC的值由CPU在执行指令过程中进行修改；

## 5.2 指令执行过程

### 5.2.1 指令周期

**指令周期：CPU完成一条指令的时间**

- 指令周期被划分为几个不同的阶段，每个阶段所需的时间称为**机器周期（CPU工作周期）**，通常等于取指时间（访存时间）
- **时钟周期（T周期/节拍脉冲）\处理操作的\最基本的单位**
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/63dcce7aa64049fb97156784fb230a31.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/771e224a6eb24f94b5045beeedb97d8d.png)

- 一个机器周期内包含的时钟周期个数由该机器周期内完成动作所需的时间决定
- 一个指令周期内包含的及其周期个数与指令所要求的动作有关
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/bd6431d283dd45cabf73c4d8fdfa6052.png)
- 间接寻址时，需要多访问一次存储器取出有效地址，因此有**间址周期**
- 当CPU采用中断方式实现主存与I/O交换信息时，CPU在每条指令的执行周期结束前，都要发出中断查询信号，检测是否有I/O提出请求，若有请求则CPU需要进入中断响应阶段，即**中断周期**
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/fee3c9470022428cae5792cd19b4596d.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/0bdd59d6fa3e4f0b9dd840eae2fc44e1.png)

- **信息流**：根据指令要求一次访问的数据序列，在指令执行的不同阶段，要求访问的数据序列不同，对不同的指令，其数据流往往也不同



1. **存取周期：**指成存储器进行两次独立的存储器操作（连续两次读或写操作）所需的最小时间间隔；

2. CPU内部操作速度较快，而CPU访问一次存储器的时间较长，因此机器周期通常由==存取周期==确定；

3. 采用DMA方式传递数据时，每传送一个数据就要占用存取周期；

4.  指令总是根据程序计数器从主存中读出；

5. 取指操作是自动进行的，控制器不需要得到相应的指令；

6. 指令周期的第一个机器周期是取指周期，即从主存中取出指令字；指令地址码的解析发生在取有效地址阶段；

7. 通常把通过一次总线事务访问一次主存或I/O的时间定为一个==机器周期==；

8. 在指令的执行周期完成后，处理器会判断是否出现中断请求，只有在出现中断请求时才会进入中断周期；所以并不是每个指令周期都包含中断响应机器周期；

9. 不同长度的指令，其取指操作可能是不同的。例如，双字指令、三字指令与单字指令的取指操作是不同的；

10. 控制器根据在不同阶段对内存的访问确定访问的是指令还是数据；

11. 若指令字长等于存储字长，则取指周期等于机器周期；

12. 指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数，与机器字长没有必然的联系；但为了硬件设计方便，指令字长一般取字节或存储字长的整数倍；

    

### 5.2.3 指令的执行过程与信息流

1. 取指周期

- CPU到哪个单元存取指令？
- 如何形成后继指令地址？
- **按PC内容取出指令，并将PC内容递增，当出现转移情况时，指令地址在执行周期被修改**
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/f0f6b52c70f64224bc0bf7957db94aef.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/4eb7b142acce44c79e67fdfe9cb84b1d.png)

1. 间址周期（并非所有指令的执行都有间址周期）

- 取出操作数的有效地址
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/144831579d924e34bc123e61184194b1.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/1556062744634c6f957af0f957dcd3cd.png)

1. 执行周期
2. 中断周期
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/5ed2854900e34af3af7d9d705bb664f1.png)

### 5.2.3 指令执行方案

> 1. 单指令周期
>
> - 所有指令都选用相同的执行时间完成
> - 每一条指令都在固定的时钟周期内完成，指令之间**串行执行**，即下一条指令只能在前一条指令结束后才能启动
>
> 1. 多指令周期
>
> - 对不同类型的指令选用不同的执行步骤
> - **串行执行**，但可以选用不同个数的时钟周期来完成不同指令的执行过程
>
> 3.流水线方案
>
> - 指令之间可以**并行执行**的方案
> - 在每个时钟脉冲周期完成一条指令的执行过程（理想情况）
> - 通过在每个时钟周期启动一条指令，尽可能让多条指令同时运行，但各自处在不同的执行步骤中



## 5.3 数据通路的功能和基本结构

- **数据通路**：数据在功能部件之间传送的路径。包括数据通路上流经的部件，如ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等；数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制；

1. 数据通路的功能
   实现CPU内部的运算器和寄存器，以及寄存器之间的数据交换
2. 数据通路的基本结构：

> ① CPU内部总线方式
>
> - 将所有寄存器的输入端与输出端都连接到一条或多条公共的通路上
> - 结构简单，但数据传输存在较多冲突现象，性能能较低
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/b54546573e6b4c4ea2ed320e637b3de4.png)

> ② 专用数据通路方式
>
> - 根据指令执行过程中的数据和地址的流动安排接线路，避免使用共享的总线，性能比较高，但硬件量较大
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/5fd17cf517d64b07989900adbc0054c1.png)
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/2605fac918174f14b0cb61473c2ffd70.png)



常见数据通路的数据传送

1. 寄存器之间的数据传送
2. 主存与CPU之间的数据传送
3. 执行算数或逻辑运算

采用CPU内部总线方式的数据通路的特点：结构简单，实现容易，性能较低，存在较多的冲突现象；

不采用CPU内部总线方式的数据通路特点：结构复杂，硬件量大，不易实现，性能高，基本不存在数据冲突现象；

单周期处理器必须配合多总线结构，单总线必须配合多周期处理器；

常见问题：

1. 在ALU的一个输入端口为什么要设置一个暂存器？

   答：因为采用了单总线结构，因此若无暂存器，则ALU的A,B端口会同时获得两个相同的数据，十数据通路不能正常工作；

2. PC自增问题：

   也可以使用ALU实现，此时一般在ALU的一个输入端放置PC自增所需的固定值；

3. 三态门：

   用于控制两个部件之间的通断；



单周期处理器：单周期处理器是指所有指令周期为一个时钟周期的处理器。

- 一般，单周期处理器需配合多总线结构，单总线结构需配合多周期处理器；

- 单周期处理器每条指令都需要在一个时钟周期内完成，且要考虑比较慢的指令，因此，这种处理器的时钟频率较低；

  

## 5.4 控制器的功能和工作原理

### 5.4.1 控制器的结构和功能



### 5.4.2 硬布线控制器

设计步骤：

1. 分析每个阶段的微操作序列；

2. 选择CPU的控制方式；

3. 安排微操作时序；

4. 电路设计：

   （1）列出操作时间表

   （2）写出微操作命令的最简表达式

   （3）画出逻辑图

硬布线控制器的特点：

指令越多，设计和实现就越复杂，因此一般用于RISC（精简指令集系统）

如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难。

由于使用纯硬件实现控制，因此执行速度很快。微操作控制信号由组合逻辑电路即时产生。

### 5.4.3 微程序控制器

### 5.4.4 习题知识点

1. 取指令操作是控制器固有的功能，不需要在操作码控制下进行；

2. 在组合逻辑控制器中，微操作控制信号的形成主要与以下信号有关：

   ![image-20220906155939578](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220906155939578.png)

   ①经指令译码器译码产生的指令信息；

   ②时序系统产生的机器周期信号和节拍信号；

   ③来自执行单元的反馈信号即标志；

   前两者是主要因素。

   1. 执行公用的取指微程序从主存中取出机器指令后，由机器指令的==操作码字段==指出各个微程序的入口地址；

3. 微指令的设计目标和指令结构的设计目标类似，都是基于<u>执行速度、灵活性和指令长度</u>这三个方面考虑的。而控制存储器容量的大小与微指令的设计目标无关；

4. 一条微指令存放在控制器的一个控制存储器单元中；

5. 硬布线控制器需要结合各微操作的节拍安排，综合分析，写出逻辑表达式，在设计成逻辑电路图，因此时序系统比较复杂；而微程序只需按照节拍的安排，顺序执行微指令，因此比较简单；

6. CPU控制器（CU）主要由三个部件组成：指令寄存器、程序计数器和操作控制器。

   状态条件寄存器，又叫标志寄存器或程序状态字寄存器，属于运算器；

7. 主存储器用于存储指令和数据，由RAM和ROM实现；

8. 控制存储器用来存放是实现指令系统的所有微指令，是一种只读存储器，机器运行时只读不写，在CPU的控制器内；

9. MM和CS均是按照微指令的==地址==访问；

10. 时钟周期以相邻状态单元间组合逻辑的最大延时为基准确定；

11. 汇编程序员可见的寄存器有基址寄存器（用于实现多道程序设计或者编制浮动程序）和状态/标志寄存器、程序计数器PC及通用寄存器组；而MAR、MDR、IR是CPU的内部工作寄存器，对汇编程序员不可见；微指令寄存器属于微程序控制器的组成部分，他是硬件设计者的任务，对汇编程序员是透明的；

12. 主存储器中，PC的位数与MAR相同，其他寄存器的位数与MDR的相同；



## 5.5 异常和中断机制

**中断：**

- 异常：

  | 异常名称                            | 能否解决 | 返回           |           例子           |
  | :---------------------------------- | -------- | -------------- | :----------------------: |
  | 故障fault：当前指令引起的意外事件； | 能       | 返回当前指令   |        缺页、缺段        |
  | 陷阱trap：陷阱指令自愿陷入；        | 能       | 返回下一条指令 |         系统调用         |
  | 终止abort：硬件检测到致命错误；     | 不能     | 不会返回       | 控制器出错、存储器校验错 |

- 外中断：

  1. IO设备产生的中断；返回下一条指令；

     

> - 故障异常和自陷异常属于程序性异常（软件异常）；

> - 终止异常和外中断属于硬件中断；



注：

1. 当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行；
2. 

## 5.6 指令流水线



### 5.6.3 流水线的冒险与处理

**1.结构冒险**



**2.数据冒险**

1. 写后读（RAW）：{先写指令，后一条为读指令} 指令A写入之前，指令B去读，这是B读出的是错误的；
2. 读后写（WAR）：{先读指令，后一条为写指令} A读出之前，B先写，这时读出的是B写入的内容，而不是原来的内容；
3. 写后写（WAW）：{先写指令，后一条为写指令} A写入之前，B先写，这时寄存器或存储器中的内容是A的，本来应该存储B写入的内容；

流水线按序流动时，在RAW、WAR和WAW中，只可能出现RAW相关；



**3.控制冒险**

 什么指令可能导致控制冒险？

会改变PC值的：

1. 无条件转移（call、ret属于无条件转移）

   - EX，第三个段改变PC；
   - 解决方法：停两个周期，再取下一个指令（IF段），就不会发生控制冒险；

2.  有条件转移：

   - M，第四个段改变PC；

   - 解决方法：停三个周期，再取下一条指令（IF段），就不会发生控制冒险；

   - 若未发生转移（不满足条件），则不会发生控制冒险；

     

总结：

1. ​	加入若干空操作可以避免结构冒险、数据冒险、控制冒险；
2. 通过编译器调整指令执行顺序可解决**部分**控制冒险；
3. 

### 5.6.4 流水线的性能指标

**1.流水线的吞吐率**

TP=$\frac{n}{(k+n-1)△t}$

n→∞时，最大吞吐率为TP~max~=$\frac{1}{△t}$

**2.流水线的加速比**

S=$\frac{kn}{k+n-1}$

n→∞时，最大加速比为S~max~=k



### 5.6.5 高级流水线技术

**1.超标量流水线技术**

**2.超长指令字技术**

**3.超流水线技术**



**动态流水线和静态流水线**
按同一时间内各段之间的连接方式，流水线可分为*静态流水线*和*动态流水线*。
**静态流水线**指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
**动态流水线**指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样
对提高流水线的效率很有好处，但会使流水线控制变得很复杂。

### 5.6.6 习题知识点

1. 流水CPU只需增加少量硬件就可以实现计算机运算速度的成倍增加，因此流水CPU利用的是时间并行性；

2. 所有的RISC都采用流水线技术，大部分CISC同样采用了流水线技术；

3. 空间并行：即资源重复，多个功能部件共同执行同一任务的不同部分；

   时间并行：即时间重叠，多个功能部件在时间上相互错开，轮流重叠执行不同任务的相同部分；

4. 流水CPU和多媒体CPU无必然联系；

5. 结构冒险、数据冒险、控制冒险均可采用加入若干空操作来避免；

6. 通过编译器调整指令执行顺序可解决**部分**控制冒险；

7. 超标量流水线技术不能缩短流水线功能段的执行时间；可以结合动态调度技术提高指令执行并行性；

8. 数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号；所以数据通路不包含控制部件；

9. 单周期CPU：一个时钟周期完成一条指令，如果一个程序有多条指令，则时钟周期的时间根据执行时间最长的那条指令为主。执行一条指令就需要一个时钟周期则CPI为1。

10. 多周期CPU：一条指令被分成了若干个阶段（多个机器周期，如取指，间址，执行，中断），假设为n个，每执行一条指令需要花费n个时钟周期，所以执行一条指令就需要n个时钟周期CPI为n。

## 5.7 多处理器的基本概念



# 第六章：总线

## 6.1 总线概述

### 6.1.3 系统总线结构

1.单总线结构：

2.双总线结构：（存在通道结构）

- 主存总线：用于在CPU、主存和通道之间传递数据；

  支持突发（猝发）传送：送出一个地址，收到多个地址连续的数据；

- I/O总线：用于在多个外部设备与通道之间传递数据；

3.三总线结构：

- 主存总线：
- I/O总线：
- 直接内存访问（DMA）总线：

### 6.1.4 总线标准（不考）

![image-20220416110221237](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220416110221237.png)

### 6.1.6 习题知识点

1. 间址寻址首次访问所得到的信息是操作数的有效地址，该地址作为数据通过数据总线传送至CPU，地址总线适用于CPU选择主存单元地址和I/O端口地址的单向总线，不能回传；

2. 地址总线用来指明CPU欲访问的存储单元或I/O端口的地址；

3. 各总线通过桥接器相连，桥接器起流量交换的作用；

5. 突发传送方式把多个数据单元作为一个独立传输处理，从而最大化设备的吞吐量；现实中一般用支持突发传送方式的总线来提高存储器的读写效率；

6. 分离事务通信是总线复用的一种，相比单一的传输线路可以提高总线的利用率；

7. 各总线通过桥接器相连，桥接器起流量交换的作用；

8. 三通道存储器总线带宽为 ：3*总线带宽；

   

## 6.2 总线事务和定时

四种通信方式：

1、同步通信；

2、异步通信；

在异步串行通信中，至少需要一位起始位和停止位；

3、半同步通信：

支持速度相差较大的设备之间的通信；

![image-20220821170012147](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220821170012147.png)

4、分离式通信：

![image-20220821170228502](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220821170228502.png)

### 6.2.4 习题知识点

1. 在异步总线中，传送操作按需分配时间；
1. 在系统总线的数据线上，可能传输指令、操作数、中断类型号；不可能传输握手信号；




# 第七章：输入/输出系统

## 7.2 I/O接口

I/O总线上数据线传输的信息包括：读写数据、IO接口中的命令字、状态字、控制字、中断类型号；

地址线：指明I/O端口;

控制线：读/写IO端口的信号、中断请求信号；



**I/O端口及其编址**

CPU能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只执行写操作；

编址方式：

| 统一编址                         | 单独编址                       |
| -------------------------------- | ------------------------------ |
| 内存存储单元和IO设备共用存储空间 | 内存存储单元和IO设备的地址独立 |
| 访存指令可以访问IO设备           | 需要专门的IO指令访问IO设备     |
| 地址码区分                       | 指令类型区分                   |



1. 在统一编址的情况下，访存指令也可访问I/O设备；在独立编制的方式下，访问I/O地址空间必须通过专门的I/O指令；

2. 在统一编址方式下，指令靠地址码区分内存和I/O设备，若随意在地址的任何地方编址，将给编程造成巨大的混乱；

3. 磁盘驱动器向盘片磁道记录数据时采用==串行==方式写入；

4. 程序员进行系统调用访问设备使用的是逻辑地址；

5. I/O接口即I/O控制器，其功能是接收主机发送的I/O控制信号，并实现主机和外部设备之间的信息交换；

6. 打印机适配器、网络控制器、可编程中断控制器均是I/O接口，磁盘驱动器不是I/O接口；

7. I/O指令实现的数据传送通常发生在通用寄存器和I/O端口之间；因为CPU与IO设备工作方式、速度等不匹配，所以需要IO端口的协调；

   

## 7.3 I/O方式

### 7.3.1 程序查询方式

<img src="D:\考研\专业课\计算机组成原理\笔记图片\IO程序查询.jpg" style="zoom:60%;" />



### 7.3.2 程序中断方式

<img src="D:\考研\专业课\计算机组成原理\笔记图片\中断IO.jpg" style="zoom: 50%;" />



**中断向量：**

![image-20220823165315207](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220823165315207.png)

- 中断向量：中断服务程序的入口地址；
- 中断向量地址：中断服务程序的入口地址的地址；
- 中断向量表：存放中断向量的那块区域；
- 向量中断：采用中断向量的中断；

### 7.3.3 DMA方式

![](D:\考研\专业课\计算机组成原理\笔记图片\DMA.jpg)

DMA控制：

DMA设备每次向DMA接口缓冲区中传送一个字，满了发出DMA总线请求；

缓冲区满了会传送到主存中的块，块满会发出DMA中断请求；







1. 在总线仲裁方式中，独立请求方式相应时间最快，是以增加控制线为代价的；

2. ==总线仲裁方式一般是指I/O设备争用总线的判优方式，而中断判优方式一般是指I/O设备争用CPU的判优方式；==

3. 中断判优逻辑既可以通过硬件实现，又可以通过软件实现；

4. 中断服务程序一般是操作系统模块；

5. 中断向量方法可提高中断源的识别速度；

6. 外部事件如按Esc键以退出运行的程序，属于外中断；

7. Cathe完全由硬件实现的，不会设计中断层面；

8. 虚拟存储器失效如缺页等，会发生缺页中断，属于内中断；

9. 浮点数运算下溢，直接当做机器零处理，而不会引发中断；

10. 浮点数上溢，表示超过了浮点数的表示范围，属于内中断；

11. 中断分类：

    ![image-20220823183006256](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220823183006256.png)

12. 中断服务程序的最后指令通常是中断返回指令，与无条件转移指令不同的是，他不仅要修改PC的值，而且要将CPU中的所有寄存器都回复到中断前的状态；

13. 中断响应由高到低的优先次序是：机器故障—>访管—>外部中断—>程序—>重新启动

14. 用户程序需要输入输出时，需要调用操作系统提供的接口（请求操作系统服务），此时会引起**访管中断**，系统由用户态转为核心态；

15. 允许中断触发器置0表示关中断，由中断隐指令完成，即由硬件自动完成；

16. 注意区分中断响应次序和中断处理次序：中断响应次序由硬件排队电路决定，不可更改；中断处理次序可以通过中断屏蔽技术改变中断的处理次序；

17. 程序查询方式：CPU与外设串行工作，传送与主程序串行工作；

    中断方式：CPU与外设并行工作，传送与主程序串行工作；

    DMA方式：CPU与外设、传送与主程序都是并行的；

18. CPU对DMA的响应可在指令执行过程中的任何两个存取周期之间；DMA请求的响应时间可以发生在每个机器周期结束时，只要CPU不占用总线；

19. 每个机器周期结束后，CPU就可以响应DMA请求。注意区别：DMA在与主存交互数据时通过周期窃取方式，窃取的是存取周期；

20. DMA的优先级要比外中断（非屏蔽中断、可屏蔽中断）高；

21. DMA中断 >不可屏蔽中断> 内部异常 >可屏蔽中断;

22. 如果不开中断，内中断和非屏蔽中断仍可响应；

23. 只有DMA方式是靠硬件电路实现的，三种基本的程序控制方式即直接程序传送，程序中断、通道控制都需要程序的干预；

24. 中断发生时，程序计数器内容的保护和更新是由硬件自动完成，即由中断隐指令完成；

25. DMA传送前由设备驱动程序设置传送参数；

26. DMA方式传送数据时，挪用周期不会改变CPU现场，因此无需占用CPU的程序计数器和寄存器；

27. 通用寄存器的保护属于保护现场，由中断程序完成；

28. DMA在数据传送过程中，是由硬件完成的，CPU不参与；

    
