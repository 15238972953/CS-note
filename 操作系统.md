# 重难点

第四章：文件管理，FCB

# 第一章 计算机系统概述

## 1.1 操作系统基本概念

**操作系统作为用户与计算机硬件系统之间的接口：**



![image-20220909160356556](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220909160356556.png)

### 1.1.2习题知识点

1. 源程序资源不是操作系统应该管理的；操作系统管理计算机的硬件和软件资源，包括CPU，内存，外存；这些资源统称为计算机资源；
2. 文件不属于硬件资源，但属于计算机资源；
3. 编译器的实质是一段程序指令，它存储在计算机中，不是操作系统关心的问题；
4. 并发性是指若干事件在同一时间间隔内发生，而并行性是指若干事件在同一时刻发生；
5. 系统调用是由操作系统提供给用户的，它只能通过用户程序间接使用；
6. 系统调用的目的是**请求系统服务**；
7. 广义指令就是系统调用命令，而命令解释器属于命令接口，shell是命令解析器，它也属于命令接口；系统中的缓存全部由操作系统管理，对用户是透明的，操作系统不提供管理系统缓存的系统调用；
8. 单道程序设计的基本特征是顺序性，多道程序设计的基本特征是制约性、间断性、共享性；
9. 库函数是高级语言中提供的与系统调用对应的函数（也有些库函数与系统调用无关），目的是隐藏“访管”指令的细节，使系统调用更为方便、抽象。但是，库函数属于用户程序而非系统调用，是系统调用的上层；
10. 陷入指令（Traps），又叫做自陷指令或访管指令，用于实现在用户态下运行的进程调用操作系统内核程序，即当运行的用户进程或系统实用进程欲请求操作系统内核为其服务时，可以安排执行一条陷入指令引起一次特殊异常。

## 1.2 操作系统发展历程

### 批处理阶段：

单道批处理系统：自动性，顺序性，单道性；

多道批处理系统：多道，宏观上并行，微观上串行；

优点：资源利用率高，多道程序共享计算机资源，从而使各资源得到充分利用；系统吞吐量大，CPU和其他资源保持“忙碌”状态。

缺点：用户响应时间较长；不提供人机交互能力，用户既不能了解自己程序的运行情况，又不能控制计算机；

### 分时操作系统：

特点：同时性，交互性，独立性，及时性；

### 实时操作系统：

可分为：硬实时系统和软实时系统；

特点：及时性，可靠性；（交互性不如分时系统）

### 网络操作系统和分布式计算机系统

网络操作系统：网络中各种资源的共享及各台计算机之间的通信；

分布式计算机系统：分布性和并行性；（建立在网络操作系统上，控制功能均为分布式）

两者本质不同：分布式操作系统中的若干计算机相互协同完成同一任务；

### 1.2.2 习题知识点

1. 操作系统的基本类型主要有：批处理操作系统、分时操作系统和实时操作系统；
2. 实时系统的进度调度，通常采用抢占式的优先级高者优先；
3. 资源利用率不是设计实时操作系统的主要追求目标；
4. 分时操作系统的一个重要性能是系统的响应时间，对操作系统的优先级+非抢占式调度算法因素进行改进有利于改善系统的响应时间；
5. 分时操作系统追求的目标是比较快速的响应用户；
6. 分时系统的响应时间T的比例关系：T=Q*N，其中Q是时间片，N是用户数；
7. 中断技术使得多道批处理的I/O设备可与CPU并行工作；
8. 多任务操作系统可在同一时间内运行多个应用程序，具有并发和并行的特点；
9. 多个任务必须互斥地访问共享资源，为达到这一目标必须对共享资源进行必要的保护；
10. 代码可重入：多个进程/线程共享同一段代码，执行结果不会互相影响。这类代码可以很安全的被多个进程/线程共享；



## 1.3 操作系统运行环境

特权指令：是指不允许用户直接使用的指令，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令；

非特权指令：是指允许用户直接使用的指令，他不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏；

操作系统的内核包括四个方面：

1. 时钟管理

   

2. 中断机制

   中断机制中，只有一小部分功能属于内核，他们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力；

3. 原语

4. 系统控制的数据结构及处理

### 1.3.2 中断和异常

<img src="C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220502112319862.png" alt="image-20220502112319862" style="zoom:80%;" />

注：

内部中断（异常）是不可屏蔽的，一旦出现，立即处理；

外部中断属于硬件中断；



系统调用：系统调用功能是操作系统向用户程序提供的接口；

- 设备管理
- 文件管理
- 进程管理
- 进程通信
- 内存管理

注：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的；

访管指令是用户态使用的，所以它不可能是特权指令；

[操作系统~用户态进入内核态的方式(中断、异常、系统调用)_Listen-Y的博客-CSDN博客_用户态进入内核态](https://blog.csdn.net/Shangxingya/article/details/113664779)

### 1.3.2 习题知识点

1. 通用操作系统使用时间片轮转调度算法，用户运行程序并不需要预先预定运行时间；

2. 在通用操作系统管理下的计算机上运行程序，需要确定起始地址，并从这个地址开始执行；

3. 多道性是为了提高系统利用率和吞吐量而提出来的；

4. I/O通道实际上是一种特殊的处理器，它具有执行I/O指令的能力，并通过执行通道程序来控制I/O操作；

5. 中断是操作系统必须提供的功能；在一些专业性较强，实时性要求较高的操作系统中，可不提供系统调用，以换取效率，如NASA使用的Vxworks系统（在火箭卫星上使用）；

6. 中断处理流程的前三个步骤是由硬件直接实现（隐指令）的；

   地址映射中需要基地址（或页表）寄存器和地址加法器的支持；

   在时钟管理中，需要硬件计数器保持时钟的运行；

   进程调度由调度算法决定CPU使用权，由操作系统实现，不需要硬件的支持；

7. 进入中断的处理程序一定是OS程序；（即向量地址中的 JMP XXX 语句）

8. 广义指令（即系统调用，指的是一系列指令的集合）的调用可能发生在用户态，但广义指令存在于核心态，所以指令一定在核心态执行；

9. 系统调用是操作系统提供给用户程序的接口，系统调用发生在用户态，被调用程序在核心态下执行；

10. 用户程序设计时，使用系统调用命令，该命令经过编译后，形成若干参数和陷入指令；

11. 用户及其应用程序和应用系统是通过系统调用提供的支持和服务来使用系统资源完成其操作的；

12. 计算机从用户态到核心态的转换是由硬件完成的，这是通过中断机制来实现的；

13. 置时钟指令只能在核心态下执行；寄存器清0可以在用户态下执行；

14. CPU核心态可以执行特权指令，也可以执行非特权指令，但不能执行访管指令；

15. OS内核功能：

    - 支撑功能：中断处理，时钟管理，原语操作；
    - 资源管理功能：进程管理，存储器管理，设备管理；

16. 中断处理时保存的数据：

    1. 硬件负责：
       - 程序计数器PC
       - 程序状态字PSW
    2. 操作系统负责：其他有必要保存的信息，如通用寄存器；

17. 在用户态执行：命令解释程序；

    在核心态执行：中断（包括内部中断和外部中断），进程调度；

18. 

    

## 1.4 操作系统结构

**微内核**：

微内核结构将操作系统分为两大部分：微内核和多个服务器；

微内核通常包含：①与硬件处理紧密相关的部分；②一些较基本的功能；③客户和服务器之间的通信；



### 1.6.2 习题知识点

1. 低级I/O和硬件紧密相关，因此应放入微内核；
2. 低级进程管理和调度属于调度功能的机制部分，应将它放入微内核；
3. 文件系统服务是放在微内核外的文件服务器中实现的；
4. windows、linux操作系统都是宏内核操作系统；
5. 在微内核架构中，客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，这就使得微内核系统能很好地支持分布式系统；
6. 计算机操作系统的引导程序位于硬盘中；用于启动具体的设备的引导程序位于ROM中；
8. 虚拟机可以用软件实现，也可以用硬件实现；




**操作系统启动顺序：**

ROM中的引导程序——>磁盘引导程序——>分区引导程序——>操作系统的初始化程序



# 第二章 进程与线程

## 2.1进程与线程

1. 在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行；
2. 进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式；

### 2.1.5 进程的通信

1.共享存储：

![image-20220911152051149](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220911152051149.png)

2.消息传递：



3.管道通信：

在内存中开辟了一个缓冲区，只存在于内存；

管道可以看成一个循环队列；

一个管道允许多个写进程，一个读进程；

### 2.1.6 线程和多线程模型

一个线程可以创建和撤销另一个线程；

同一进程中的所有线程都是完全共享进程的地址空间的和全局变量。各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈；

线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止进程才与资源分离，此时的资源才能被其他线程利用；被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行；

**线程的实现方式：**

1. 用户级线程：

   对于设置了用户级线程的系统，其调度仍是以进程为单位进行的；

2. 内核级线程：（又称内核支持的线程）

​		

注：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分批的单位；

### 2.1.7 习题知识点

1. 线程是处理机调度的基本单位，可以独立执行程序；

2. 线程没有自己独立的地址空间，它共享其所属的进程的空间；

3. 进程之间不能直接交换数据，但可以利用操作系统提供的共享文件、消息传递、共享存储区等进行通信；

4. 进程获得处理机运行时通过调度得到的；

5. 优先级是进程调度的重要依据，分为静态和动态两种，动态优先级是根据运行情况而随机调整的；

6. 系统在发生死锁时有可能进程全部都处于阻塞态，或无进程任务，CPU空闲；

7. 程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响；也就是说，进程在执行过程中不管是不停顿的执行，还是走走停停，进程的执行速度都不会改变它的执行结果，失去封闭性后，不同速度下的执行结果不同；

8. 在多对一的线程模型中，由于只有一个内核级进程，用户级线程的“多”对操作系统透明，因此操作系统内核只能感知到一个调度单位的存在。因此该进程的一个线程被阻塞后，该进程就被阻塞，进程的其他线程当然也都被阻塞；

9. 即使在采用高优先级调度算法的系统中，一个最高优先级的进程进入就绪队列，也需要考虑是否允许抢占，当不允许抢占时，仍然需要等待；

10. C语言编写的程序在使用内存时一般分为三个段，他们分别是正文段（即代码和幅值数据段）、数据堆段和数据栈段。二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时用的变量在数据栈段；

11. 程序代码经过多次创建可对应不同进程，而同一个系统的进程（或线程）可以由系统调用的方法被不同的进程（或线程）多次使用；

12. 进程创建需要占用系统内存来存放PCB的数据结构，所以一个系统能够创建的进程总数是有限的，进程的最大数目取决于系统内存的大小，它在系统安装时就已确定；

13. 对进程的管理和控制功能是通过执行各种原语来实现的，如创建原语等；

14. 导致创建新进程的操作包括：用户登录成功（系统创建一个用户管理进程），启动程序执行，作业调度，提供服务，应用请求等；

15. 降低进程优先级的合理时机是进程时间片用完；

16. P(wait)操作表示进程请求某一资源；

17. 父进程可与子进程共享一部分资源，但不能共享虚拟地址空间，在创建子进程时，会为子进程分配资源，如虚拟地址空间等；

18. 临界资源一次只能为一个进程所用；

19. 操作系统为每个内核级线程创建线程控制块（TCB），而不是每个用户级线程；


### 三种硬件多线程（新增）

![image-20221216165330087](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20221216165330087.png)

## 2.2 处理机调度

### 2.2.3 调度的实现

**调度的层次：**

1. 高级调度（作业调度）
2. 中级调度（内存调度）
3. 低级调度（进程调度）



- 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换；
- 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此因此在访问普通临界区时可以进行调度与切换；

![image-20221202150852004](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20221202150852004.png)



### 2.2.8 习题知识点

1. 时间片轮转的主要目的是，使得多个交互的用户能够得到及时响应，使得用户以为“独占”计算机的使用，因此他没有什么偏好，也不会对特殊进程做特殊服务，但其较快的响应时间使得用户能够与计算机进行交互，改善了人机环境，满足用户需求；

2. 作业是从用户角度出发的，它由用户提交，以用户任务为单位；进程是从操作系统出发的，由系统生成，是操作系统的资源分配和独立运行的基本单位；

3. 分时系统中，响应时间与时间片和用户数成正比；

4. UNIX是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统分类，属于分时操作系统；UNIX使用的是多级反馈队列调度算法；

5. 中断由硬件保护并完成，主要是为了保证系统运行可靠、正确，提高处理速度也是一个好处，但不是主要目的；

   

## 2.3 同步与互斥

### 2.3.2 实现临界区互斥的基本方法

**1.软件实现方法**

1. 算法一：单标志法。

   ```c
   //P0进程
   while(turn!=0);
   critical section;
   turn=1;
   remainder section;
   
   //P1进程
   while(turn!=1);
   critical section;
   turn=0;
   remainder section;
   ```

   缺点：若某个进程不再进入临界区，则另一个进程也将无法进入临界区，违背**空闲让进**；

   

2. 算法二：双标志法先检查。

   ```c
   //Pi进程
   while(flag[j]);
   flag[i]=TRUE;
   critical section;
   flag[i]=FALSE;
   remainder section;
   
   //Pj进程
   while(flag[i]);
   flag[j]=TRUE;
   critical section;
   flag[j]=FALSE;
   remainder section;
   ```

   缺点：Pi和Pj可能同时进入临界区，违背**忙则等待**；

   

3. 算法三：双标志法后检查。

   ```c
   //Pi进程
   flag[i]=TRUE;
   while(flag[j]);
   critical section;
   flag[i]=FALSE;
   remainder section;
   
   //Pj进程
   flag[j]=TRUE;
   while(flag[i]);
   critical section;
   flag[j]=FALSE;
   remainder section;
   ```

   缺点：会出现双方都进不了临界区的情况，从而导致**饥饿**现象；

   

4. 算法四：Peterson`s Algorithm。

   ```c
   //Pi进程
   flag[i]=TRUE; turn=j;
   while(flag[j]&&turn==j);
   critical section;
   flag[i]=FALSE;
   remainder section;
   
   //Pj进程
   flag[j]=TRUE; turn=i;
   while(flag[i]&&turn==i);
   critical section;
   flag[j]=FALSE;
   remainder section;
   ```

​		本算法利用flag解决临界资源的互斥访问，而利用turn解决“饥饿”现象；

**2.硬件实现方法**

（1）中断屏蔽方法：适用于单处理机



（2）硬件指令方法：适用于多处理机

> TestAndSet指令：这条指令是原子操作，即执行该代码是不允许被中断；

特点：

- 退出临界区的进程负责唤醒阻塞态进程；
- 等待进入临界区的进程不会主动放弃CPU；

缺点：

不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等；

> swap指令：

​	与TestAndSet指令类似；



### 2.3.5 管程

解决同步和互斥问题；

基本特征：

- 由编译器负责实现各进程互斥的进入管程中的过程；
- 各外部进程/线程只能通过管程提供的特定入口才能访问数据；

- 每次仅允许一个进程在管程内执行某个内部过程；
- x.wait()实现的功能是阻塞该进程，并将之插入x的阻塞队列中；

### 2.3.6 经典同步问题

**1、生产者-消费者问题**

```c
semaphore mutex=1;
semaphore empty=n;
semaphore full=0;
//生产者
producter() 
{
    while(1)
    {
        producte an item in nextp;
        P(empty);
        P(mutex);
        add nextp to buffer;
        V(mutex);
        V(full);
    }
}
//消费者
consumer()
{
    while(1)
    {
        P(full);
        P(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
        consume the item;
    }
}
```



多生产者-多消费者问题：

```c

```

**2、读者-写者问题**

```c
int count=0;
semaphore mutex=1;
semaphore rw=1;
writer()
{
    while(1)
    {
        P(w);				//外层的PV实现读写公平；
        P(rw);
        writing;
        V(rw);
        V(w);				//外层的PV实现读写公平；
    }
}
reader()
{
    while(1)
    {
        P(w);				//外层的PV实现读写公平；
        P(mutex);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        V(w);				//外层的PV实现读写公平；
        reading;
        P(mutex);
        count--;
        if(count==0)
            V(rw);
        V(mutex);
    }
}
```



**3、哲学家进餐问题**

制定规则：当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；

```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex=1;
Pi()
{
	do()
	{
		P(mutex);
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
        V(mutex);
        eat;
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        think;
	}while(1);
}
```

**4、吸烟者问题**



### 2.3.7 PV操作大题做法

> 生产者消费者问题

1. 有几类进程?——每类进程对一个函数；
2. 在函数内部用中文描述动作。——只做一次 or 不断重复；
3. 在每个动作之前，是否需要P什么，若写P,则必写V；（注意隐含的互斥，缓冲区访问）
4. 所有PV操作写完之后，再去定义信号量；
5. 检查多个P操作（请求和保持）出现的地方，是否可能产生死锁；
   - 某信号量的PV连续出现（中间没有夹杂别的P），不可能死锁；
   - 连续多个P导致死锁，可尝试调整P顺序；



> 哲学家进餐问题：

P(Lock)；if（检查是否全满足）；V（Lock）

==先P同步信号量，再P互斥信号量；==

### 2.3.8 习题知识点

1. 互斥信号量初始值一般为1；同步信号量的初值根据资源数来决定；

2. 硬件方法实现进程同步时不能实现让权等待；

3. 在操作系统中，P，V操作是一种低级进程通信原语；

4. PV操作实际上是由两个不可被中断的过程组成的；

5. 管程中的wait、signal操作和信号量机制中的PV操作的区别：

   wait、signal是条件变量，没有值，仅实现排队等待功能，只能阻塞或唤醒进程；

   PV操作的反映了剩余资源数；

6. 进入区和退出区是用于实现进程互斥的代码；

   

## 2.4 死锁

### 2.4.1 死锁的概念

死锁产生的必要条件：

1. 互斥条件
2. 不剥夺条件
3. 请求并保持条件
4. 循环等待条件

![image-20221111162240128](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20221111162240128.png)

注：

当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态；

# 第三章 内存管理

## 3.1 内存管理概念

重点：==地址变换过程==



### 3.1.4 基本分页存储管理

**二级页表：**即使在内存中使用了了二级页表，但是在TLB中依然是一级查找，即一级页号和二级页号放在一起查找；

### 3.1.5 基本分段存储管理

注意区分**段长**和**段表长度**；



**分段、分页管理的对比：**

**页**是信息的**物理单位**。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的**。

**段**是信息的**逻辑单位**。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。**分段对用户是可见的**，用户编程时需要显式地给出段名。

页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。

**分页**的用户进程地址空间是**一维**的，程序员只需给出一个记忆符即可表示一个地址。
**分段**的用户进程地址空间是**二维**的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的。



### 3.1.8 习题知识点

1. 覆盖技术是**单一连续存储管理**中使用的扩大存储容量的一种技术，同样可用于固定分区分配的存储管理；

2. 动态重定位是在作业的**执行过程**中进行的；

3. 页式和段式都属于动态重定位，在执行时确定物理地址；

4. 可变分区分配：进程的存放位置可能会发生改变（紧凑）；

5. 产生内部碎片：分页式存储管理、段页式存储管理、固定分区存储管理；

   产生外部碎片：分段式存储管理；

6. 页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度；

7. 页表寄存器分为：页表基址寄存器（PTBR）和页表长度寄存器（PTLR）

8. 对重定位存储管理方式，应在整个系统中设置一个重定位寄存器；

9. 采用分页式存储管理时，一个程序如何分页是在**装作业**时决定的；

10. 程序的动态链接与程序的逻辑结构相关，分段存储管理将程序按照逻辑段进行划分，因此有利于其动态链接；

11. 可重入程序是通过减少对换数量方法来改善系统性能的；

12. 作业空间中使用的逻辑地址变为内存中的物理地址称为==重定位==；

13. 段页式存储管理基本思想：用分段方法来分配和管理用户地址空间，用分页方法来管理物理地址空间；

14. 一级页表:整个页表常驻内存，因此在查询页表时不会产生缺页中断，只有最终访存时可能缺页；

    二级页表:第一级页表常驻内存，但第二级页表并不常驻内存，因此，除了最终访存时有可能缺页，在查询
                     二级页表时也可能发生缺页；

15. 在采用二级页表的分页系统中，CPU页表基址寄存器中的内容是当前进程的一级页表的起始物理地址；

16. 页表基址寄存器中存放的都是==物理地址==；

## 3.2 虚拟内存管理

虚拟内存技术需要以下硬件的支持：

- 一定容量的内存和外存；
- 页表机制（或段表机制），作为主要的数据结构；
- 中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断；
- 地址变换机构，逻辑地址到物理地址的变换；



### 3.2.10 习题知识点

1. 页表项的内容:

   **虚拟页号:**隐含的，虚拟页号

   **物理页框号:**虚拟页面存放的物理页框位置

   **合法位**(有效位、状态位) :表示该页面是否已经调入内存。用于判断是否发生缺页(页故障)

   **修改位**(脏位):表示该页面是否被修改过。当淘汰页面时，通过修改位决定是否需要把页面写回外存

   **保护码**(保护位) :表示该页面的读、写权限。如:用于存储常量的页面，为“读”权限

2. 覆盖技术对程序员不透明；

3. 内部中断与当前执行的指令有关，中断处理结束后要继续处理被中断的那条指令（如果可以执行下去的话）；外部与当前执行的指令无关，CPU在没执行完一条指令之后会检查是否有外部中断需要处理，若需要处理，则处理结束后，返回原程序，接着执行下一条指令；![image-20220921191805314](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220921191805314.png)

4. ![image-20220921192631421](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220921192631421.png)

5. 分段存储管理便于动态链接，和信息共享；

6. 多级页表分多少级问题：**页面大小/页表项大小**，在多级页表中，每个页表的大小不能超过一个页面；

7. **进程调度**是指操作系统按某种策略或规则选择进程占用CPU进行运行的过程。进程调度完全由操作系统完成，无法通过系统调用完成；

   

# 第四章 文件管理

## 4.1 文件系统基础

**文件的基本操作：**

![image-20221114092930311](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20221114092930311.png)

在一个文件被用户进程首次打开（open系统调用）时，操作系统将文件控制块（FCB）读到内存中；

在执行read系统调用时，将文件的数据缓冲区首地址返回给用户进程；

**注意点**：

1. 树形结构不便于实现文件的共享；

2. 显式链接：一个磁盘仅设置一张FAT，开机时将FAT读入内存，并常驻内存；

3. 定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能在保证记录的顺序结构，则可实现快速检索；（即根据关键字快速找到对应记录）

4. ![image-20220924212607466](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220924212607466.png)

   ![image-20220924212938419](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220924212938419.png)

   注意区分**链式存储**和**链接分配**，**索引文件**和**索引分配**；

5. 打开文件时，并不会把文件的数据直接读入内存，只是将文件的目录项的信息复制到内存的打开文件表中；

6. vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储。他们两个是完全不同的东西，注意区分；

7. 每一个被打开的文件都有一个与之对应的VNode，VNode里面保存了具体的函数功能指针；

   



### 4.1.8 习题知识点 

1. UNIX操作系统中，输入/输出设备视为==特殊文件==；
2. 打开文件操作的主要工作是**把指定文件的目录项复制到内存指定的区域**；
3. 目录文件存放的信息是：该目录中所有子目录文件和数据文件的目录；
4. 有些操作系统中将文件描述信息从目录项中分离出来，这样做的好处是：减少查找文件时的I/O信息量；
5. 进行read系统调用时，当所读数据不在内存时，产生中断（缺页中断），原进程进入阻塞态，直到所需数据从外村调入内存后，才将该进程唤醒；
6. read（所有）系统调用通过陷入将CPU从用户态切换到核心态，从而获得操作系统提供的服务；
7. 连续结构比直接索引结构更快；
8. 访问控制机制灵活性很高，并且必须由系统实现；但安全性不高；
9. 加密保护机制安全性高；
10. 



# 第五章 输入输出管理

## 5.1 I/O管理概述

设备分类：

![image-20220711161612036](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220711161612036.png)

### 5.1.6 习题知识点

1. 共享设备必须是可寻址的和可随机访问的设备；

2. 在设备控制器中用于实现设备控制功能的是**I/O逻辑**；

3. 通道分类：

   ![image-20220927151544274](C:\Users\24504\AppData\Roaming\Typora\typora-user-images\image-20220927151544274.png)

4. 通道不可以直接控制设备，必须通过控制设备控制器间接控制设备；

5. 一个通道可以控制n个设备控制器，一个设别控制器可以控制n个设备；

6. 计算柱面号、磁头号和扇区号的工作是由设备驱动程序完成的；



## 5.2 设备独立性软件

### 5.2.2 高速缓存与缓冲区

**1.磁盘高速缓存**

磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块；

**2.缓冲区**

单缓冲区：处理每块数据用时为max(C,T)+M;

双缓冲区：处理每块数据用时为max(C+M,T);



## 5.3 

### 5.3.6 习题知识点

1. **磁盘初始化:**
   **Step1:**进行低级格式化(物理格式化)。将磁盘的各个磁道划分为扇区，并确定管理扇区所需要的各种数据结构，包括扇区校验码( 如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)
   **Step2:**将磁盘分区，每个分区由若干柱面组成(即分为我们熟悉的C盘、D盘、E盘)
   **Step3:**进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、对空闲磁盘块进行管理的数据进行初始化(如位示图、空闲分区表)

2. 传统机械硬盘**连续存取**速度比SSD快，SSD**随机存取**速度比传统机械硬盘快；

3. 静态磨损算法在没有写入数据时，SSD监测并自动进行数据分配，因此表现比动态磨损算法更优秀；

4. 磁盘扇区：物理上限制的读/写一次的基本单位；

   簇/块：操作系统限制的存储空间分配基本单位；
